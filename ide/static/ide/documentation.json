{
    "simple_menu_layer_get_selected_index": {
        "kind": "fn", 
        "name": "simple_menu_layer_get_selected_index", 
        "return_desc": null, 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "const SimpleMenuLayer *", 
                "name": "simple_menu", 
                "description": "<p>The SimpleMenuLayer for which to get the current selected row index. </p>"
            }
        ], 
        "description": "<p>Gets the row index of the currently selection menu item."
    }, 
    "LayerUpdateProc": {
        "kind": "typedef", 
        "name": "LayerUpdateProc", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for a Layer's render callback (the name of the type is derived from the words 'update procedure'). The system will call the .<code>update_proc</code> callback whenever the Layer needs to be rendered. \n</p>"
    }, 
    "dict_size": {
        "kind": "fn", 
        "name": "dict_size", 
        "return_desc": "<p>The total number of bytes which have been written to the dictionary. </p>", 
        "returns": "uint32_t", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }
        ], 
        "description": "<p>Calculates the size of data that has been written to the dictionary. AKA, the \"dictionary size\". Note that this is most likely different than the size of the backing storage/backing buffer."
    }, 
    "layer_create_with_data": {
        "kind": "fn", 
        "name": "layer_create_with_data", 
        "return_desc": "<p>A pointer to the layer. NULL if the layer could not be created </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": "<p>The frame at which the layer should be initialized. </p>"
            }, 
            {
                "type": "size_t", 
                "name": "data_size", 
                "description": "<p>The size (in bytes) of memory to allocate for callback data. </p>"
            }
        ], 
        "description": "<p>Creates a layer on the heap with extra space for callback data, and set its frame andbounds. Default values:<ul><li><p>bounds : origin (0, 0) and a size equal to the frame that is passed in.</p></li><li><p>clips : true</p></li><li><p>hidden : false</p></li><li><p><code>update_proc</code> : NULL (draws nothing) \n</li></ul>\n</p>"
    }, 
    "window_stack_pop_all": {
        "kind": "fn", 
        "name": "window_stack_pop_all", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "const bool", 
                "name": "animated", 
                "description": null
            }
        ], 
        "description": "<p>Pops all windows. See <code>window_stack_remove()</code> for a description of the animated parameter and notes. </p>"
    }, 
    "GTextAlignmentLeft": {
        "kind": "enum", 
        "name": "GTextAlignmentLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Aligns the text to the left of the drawing box. </p>"
    }, 
    "text_layer_get_text": {
        "kind": "fn", 
        "name": "text_layer_get_text", 
        "return_desc": null, 
        "returns": "const char *", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer for which to get the text </p>"
            }
        ], 
        "description": "<p>Gets the pointer to the string that the TextLayer is using. \n</p>"
    }, 
    "ACCEL_SAMPLING_25HZ": {
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_25HZ", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>25 HZ sampling rate [Default] </p>"
    }, 
    "layer_get_bounds": {
        "kind": "fn", 
        "name": "layer_get_bounds", 
        "return_desc": "<p>The bounds of the layer </p>", 
        "returns": "GRect", 
        "warning": null, 
        "params": [
            {
                "type": "const Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to get the bounds </p>"
            }
        ], 
        "description": "<p>Gets the bounds of the layer \n</p>"
    }, 
    "HOUR_UNIT": {
        "kind": "enum", 
        "name": "HOUR_UNIT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Flag to represent the \"hours\" time unit. </p>"
    }, 
    "number_window_set_step_size": {
        "kind": "fn", 
        "name": "number_window_set_step_size", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "NumberWindow *", 
                "name": "numberwindow", 
                "description": "<p>Pointer to the NumberWindow for which to set the step increment </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "step", 
                "description": "<p>The new step increment </p>"
            }
        ], 
        "description": "<p>Sets the amount by which to increment/decrement by on a button click"
    }, 
    "__FILE_NAME__": {
        "kind": "def", 
        "name": "__FILE_NAME__", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "GSizeZero": {
        "kind": "def", 
        "name": "GSizeZero", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Convenience macro to make a GSize of (0, 0). </p>"
    }, 
    "vibes_double_pulse": {
        "kind": "fn", 
        "name": "vibes_double_pulse", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Makes the watch emit two brief vibrations. </p>"
    }, 
    "property_animation_update_int16": {
        "kind": "fn", 
        "name": "property_animation_update_int16", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>", 
        "params": [
            {
                "type": "PropertyAnimation", 
                "name": "property_animation", 
                "description": "<p>The property animation for which the update is requested. </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "time_normalized", 
                "description": "<p>The current normalized time. See AnimationUpdateImplementation </p>"
            }
        ], 
        "description": "<p>Default update callback for a property animations to update a property of type <code>int16_t</code>. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types Int16Getter and Int16Setter. The implementation of this function will calculate the next value of the animation and call the setter to set the new value upon the subject."
    }, 
    "window_set_click_context": {
        "kind": "fn", 
        "name": "window_set_click_context", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p>", 
        "params": [
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The button to set the context for. </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>Pointer to data that will be passed as context. </p>"
            }
        ], 
        "description": "<p>Set the context that will be passed to handlers for the given button's events."
    }, 
    "inverter_layer_destroy": {
        "kind": "fn", 
        "name": "inverter_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "InverterLayer *", 
                "name": "inverter_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys an InverterLayer previously created by <code>inverter_layer_create</code>. </p>"
    }, 
    "TUPLE_BYTE_ARRAY": {
        "kind": "enum", 
        "name": "TUPLE_BYTE_ARRAY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The value is an array of bytes. </p>"
    }, 
    "TupletCString": {
        "kind": "def", 
        "name": "TupletCString", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "simple_menu_layer_set_selected_index": {
        "kind": "fn", 
        "name": "simple_menu_layer_set_selected_index", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "SimpleMenuLayer *", 
                "name": "simple_menu", 
                "description": "<p>The SimpleMenuLayer for which to change the selection </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "index", 
                "description": "<p>The row index of the item to select </p>"
            }, 
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>Supply true to animate changing the selection, or false to change the selection instantly. </p>"
            }
        ], 
        "description": "<p>Selects the item in the first section at given row index."
    }, 
    "app_message_register_outbox_failed": {
        "kind": "fn", 
        "name": "app_message_register_outbox_failed", 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageOutboxFailed", 
        "warning": null, 
        "params": [
            {
                "type": "AppMessageOutboxFailed", 
                "name": "failed_callback", 
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>"
            }
        ], 
        "description": "<p>Registers a function that will be called after any Outbox message is not sent with a timely ACK reply. The call to <code>app_message_outbox_send()</code> must have succeeded.</p><p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>"
    }, 
    "GRectReturn": {
        "kind": "typedef", 
        "name": "GRectReturn", 
        "return_desc": null, 
        "returns": "GRect", 
        "warning": null, 
        "params": [], 
        "description": "<p>Work-around for function pointer return type GRect avoid tripping the pre-processor to use the equally named GRect define </p>"
    }, 
    "text_layer_set_text_alignment": {
        "kind": "fn", 
        "name": "text_layer_set_text_alignment", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the alignment </p>"
            }, 
            {
                "type": "GTextAlignment", 
                "name": "text_alignment", 
                "description": "<p>The new text alignment for the TextLayer </p>"
            }
        ], 
        "description": "<p>Sets the alignment of the TextLayer \n</p>"
    }, 
    "graphics_draw_line": {
        "kind": "fn", 
        "name": "graphics_draw_line", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "p0", 
                "description": "<p>The starting point of the line </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "p1", 
                "description": "<p>The ending point of the line </p>"
            }
        ], 
        "description": "<p>Draws a 1-pixel wide line in the current stroke color"
    }, 
    "scroll_layer_set_context": {
        "kind": "fn", 
        "name": "scroll_layer_set_context", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to assign the new callback context. </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>The new callback context. </p>"
            }
        ], 
        "description": "<p>Sets a new callback context. This context is passed into the scroll layer's callbacks and also the ClickHandler for the SELECT button. If NULL or not set, the context defaults to a pointer to the ScrollLayer itself. \n</p>"
    }, 
    "dict_write_uint32": {
        "kind": "fn", 
        "name": "dict_write_uint32", 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": null
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": null
            }, 
            {
                "type": "const uint32_t", 
                "name": "value", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "NumAnimationCurve": {
        "kind": "enum", 
        "name": "NumAnimationCurve", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Number of available AnimationCurve types. </p>"
    }, 
    "bluetooth_connection_service_unsubscribe": {
        "kind": "fn", 
        "name": "bluetooth_connection_service_unsubscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unsubscribe from the bluetooth event service. Once unsubscribed, the previously registered handler will no longer be called. </p>"
    }, 
    "GCornerBottomRight": {
        "kind": "enum", 
        "name": "GCornerBottomRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Bottom-Right corner. </p>"
    }, 
    "ActionBarLayer": {
        "kind": "typedef", 
        "name": "ActionBarLayer", 
        "return_desc": null, 
        "returns": "struct ActionBarLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "persist_write_bool": {
        "kind": "fn", 
        "name": "persist_write_bool", 
        "return_desc": null, 
        "returns": "status_t", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to write to. </p>"
            }, 
            {
                "type": "const bool", 
                "name": "value", 
                "description": "<p>The boolean value to write. </p>"
            }
        ], 
        "description": "<p>Writes a bool value flag for a given key into persistent storage."
    }, 
    "GPathInfo": {
        "kind": "typedef", 
        "name": "GPathInfo", 
        "return_desc": null, 
        "returns": "GPathInfo", 
        "warning": "<p>Note that this data structure only refers to an array of points; the points are not stored inside this data structure itself. In most cases, one cannot use a stack-allocated array of GPoints. Instead one often needs to provide longer-lived (static or \"global\") storage for the points. </p>", 
        "params": [], 
        "description": "<p>Data structure describing a naked path"
    }, 
    "window_stack_get_top_window": {
        "kind": "fn", 
        "name": "window_stack_get_top_window", 
        "return_desc": "<p>The topmost window on the stack that belongs to the app or NULL if no app window could be found. </p>", 
        "returns": "Window *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Gets the topmost window on the stack that belongs to the app."
    }, 
    "AnimationTimingFunction": {
        "kind": "typedef", 
        "name": "AnimationTimingFunction", 
        "return_desc": null, 
        "returns": "int32_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>// group UI </p>"
    }, 
    "MenuIndex": {
        "kind": "typedef", 
        "name": "MenuIndex", 
        "return_desc": null, 
        "returns": "MenuIndex", 
        "warning": null, 
        "params": [], 
        "description": "<p>Data structure to represent an menu item's position in a menu, by specifying the section index and the row index within that section. </p>"
    }, 
    "E_OUT_OF_STORAGE": {
        "kind": "enum", 
        "name": "E_OUT_OF_STORAGE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Insufficient long-term storage available. </p>"
    }, 
    "graphics_draw_rect": {
        "kind": "fn", 
        "name": "graphics_draw_rect", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle for which to draw the outline </p>"
            }
        ], 
        "description": "<p>Draws a 1-pixel wide rectangle outline in the current stroke color"
    }, 
    "status_t": {
        "kind": "typedef", 
        "name": "status_t", 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "app_timer_reschedule": {
        "kind": "fn", 
        "name": "app_timer_reschedule", 
        "return_desc": "<p>true if the timer was rescheduled, false if the timer has already elapsed </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "AppTimer *", 
                "name": "timer_handle", 
                "description": "<p>The timer to reschedule </p>"
            }, 
            {
                "type": "uint32_t", 
                "name": "new_timeout_ms", 
                "description": "<p>The new expiry time in milliseconds from the current time </p>"
            }
        ], 
        "description": "<p>Reschedules an already running timer for some point in the future."
    }, 
    "NumberWindowCallback": {
        "kind": "typedef", 
        "name": "NumberWindowCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for NumberWindow callbacks. </p>"
    }, 
    "ARRAY_LENGTH": {
        "kind": "def", 
        "name": "ARRAY_LENGTH", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "SNIFF_INTERVAL_REDUCED": {
        "kind": "enum", 
        "name": "SNIFF_INTERVAL_REDUCED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Reduce the sniff interval to increase the responsiveness of the radio at the expense of increasing Bluetooth energy consumption by a multiple of 2-5 (very significant) </p>"
    }, 
    "grect_clip": {
        "kind": "fn", 
        "name": "grect_clip", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "rect_to_clip", 
                "description": "<p>The clipped rectangle. </p>"
            }, 
            {
                "type": "GRect", 
                "name": "rect_clipper", 
                "description": "<p>The rectangle of which the edges will serve as \"scissors\" in order to trim <code>rect_to_clip</code>. </p>"
            }
        ], 
        "description": "<p>Trim one rectangle using the edges of a second rectangle."
    }, 
    "window_get_click_config_context": {
        "kind": "fn", 
        "name": "window_get_click_config_context", 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to get the click config provider context </p>"
            }
        ], 
        "description": "<p>Gets the current click configuration provider context of the window."
    }, 
    "MenuRowAlignCenter": {
        "kind": "enum", 
        "name": "MenuRowAlignCenter", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Scroll the contents of the MenuLayer in such way that the selected row is centered relative to the visible area. </p>"
    }, 
    "DICT_INTERNAL_INCONSISTENCY": {
        "kind": "enum", 
        "name": "DICT_INTERNAL_INCONSISTENCY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>"
    }, 
    "persist_write_data": {
        "kind": "fn", 
        "name": "persist_write_data", 
        "return_desc": "<p>The number of bytes written. </p>", 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to write to. </p>"
            }, 
            {
                "type": "const void *", 
                "name": "data", 
                "description": "<p>The pointer to the blob of data. </p>"
            }, 
            {
                "type": "const size_t", 
                "name": "size", 
                "description": "<p>The size in bytes. </p>"
            }
        ], 
        "description": "<p>Writes a blob of data of a specified size in bytes for a given key into persistent storage. The maximum size is <code>PERSIST_DATA_MAX_LENGTH</code>"
    }, 
    "action_bar_layer_set_click_config_provider": {
        "kind": "fn", 
        "name": "action_bar_layer_set_click_config_provider", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the action bar had already been added to a window and the window is currently on-screen, the click configuration provider will be called before this function returns. Otherwise, it will be called by the system when the window becomes on-screen. </p><p>The .raw handlers cannot be used without breaking the automatic highlighting of the segment of the action bar that for which a button is </p>", 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar for which to assign a new click configuration provider </p>"
            }, 
            {
                "type": "ClickConfigProvider", 
                "name": "click_config_provider", 
                "description": "<p>The new click configuration provider </p>"
            }
        ], 
        "description": "<p>Sets the click configuration provider callback of the action bar. In this callback your application can associate handlers to the different types of click events for each of the buttons, see Clicks."
    }, 
    "graphics_context_set_stroke_color": {
        "kind": "fn", 
        "name": "graphics_context_set_stroke_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The graphics context onto which to set the stroke color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": "<p>The new stroke color </p>"
            }
        ], 
        "description": "<p>Sets the current stroke color of the graphics context."
    }, 
    "layer_insert_below_sibling": {
        "kind": "fn", 
        "name": "layer_insert_below_sibling", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer_to_insert", 
                "description": "<p>The layer to insert into the hierarchy </p>"
            }, 
            {
                "type": "Layer *", 
                "name": "below_sibling_layer", 
                "description": "<p>The layer that will be used as the sibling layer above which the insertion will take place </p>"
            }
        ], 
        "description": "<p>Inserts the layer as a sibling behind another layer. The <code>below_layer</code> has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically."
    }, 
    "AnimationCurveLinear": {
        "kind": "enum", 
        "name": "AnimationCurveLinear", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Linear curve: the velocity is constant. </p>"
    }, 
    "AppTimerCallback": {
        "kind": "typedef", 
        "name": "AppTimerCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>The type of function which can be called when a timer fires. The argument will be the <code>callback_data</code> passed to <code>app_timer_register()</code>. </p>"
    }, 
    "E_INVALID_ARGUMENT": {
        "kind": "enum", 
        "name": "E_INVALID_ARGUMENT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The function was not called correctly. </p>"
    }, 
    "window_get_user_data": {
        "kind": "fn", 
        "name": "window_get_user_data", 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null, 
        "params": [
            {
                "type": "const Window *", 
                "name": "window", 
                "description": "<p>The window for which to get the user data </p>"
            }
        ], 
        "description": "<p>Gets the pointer to developer-supplied data that was previously set using <code>window_set_user_data()</code>."
    }, 
    "E_OUT_OF_MEMORY": {
        "kind": "enum", 
        "name": "E_OUT_OF_MEMORY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Insufficient allocatable memory available. </p>"
    }, 
    "app_timer_cancel": {
        "kind": "fn", 
        "name": "app_timer_cancel", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "AppTimer *", 
                "name": "timer_handle", 
                "description": null
            }
        ], 
        "description": "<p>Cancels an already registered timer. Once cancelled the the handle may longer be used for any purpose. </p>"
    }, 
    "ScrollLayer": {
        "kind": "typedef", 
        "name": "ScrollLayer", 
        "return_desc": null, 
        "returns": "struct ScrollLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "app_comm_set_sniff_interval": {
        "kind": "fn", 
        "name": "app_comm_set_sniff_interval", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "SniffInterval", 
                "name": "interval", 
                "description": null
            }
        ], 
        "description": "<p>Set the Bluetooth module's sniff interval. The sniff interval will be restored to normal by the OS after the app's de-init handler is called. Set the sniff interval to normal whenever possible. </p>"
    }, 
    "animation_unschedule": {
        "kind": "fn", 
        "name": "animation_unschedule", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the animation was not yet finished, unscheduling it will cause its .stopped handler to get called, with the \"finished\" argument set to false. </p>", 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation to unschedule. </p>"
            }
        ], 
        "description": "<p>Unschedules the animation, which in effect stops the animation. \n</p>"
    }, 
    "DictionaryKeyUpdatedCallback": {
        "kind": "typedef", 
        "name": "DictionaryKeyUpdatedCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Type of the callback used in <code>dict_merge()</code> \n</p>"
    }, 
    "property_animation_update_grect": {
        "kind": "fn", 
        "name": "property_animation_update_grect", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>", 
        "params": [
            {
                "type": "PropertyAnimation", 
                "name": "property_animation", 
                "description": "<p>The property animation for which the update is requested. </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "time_normalized", 
                "description": "<p>The current normalized time. See AnimationUpdateImplementation </p>"
            }
        ], 
        "description": "<p>Default update callback for a property animations to update a property of type GRect. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types GRectGetter and GRectSetter. The implementation of this function will calculate the next rectangle of the animation and call the setter to set the new rectangle upon the subject."
    }, 
    "graphics_context_set_fill_color": {
        "kind": "fn", 
        "name": "graphics_context_set_fill_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The graphics context onto which to set the fill color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": "<p>The new fill color </p>"
            }
        ], 
        "description": "<p>Sets the current fill color of the graphics context."
    }, 
    "DATA_LOGGING_CLOSED": {
        "kind": "enum", 
        "name": "DATA_LOGGING_CLOSED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The logging session was made inactive. </p>"
    }, 
    "simple_menu_layer_create": {
        "kind": "fn", 
        "name": "simple_menu_layer_create", 
        "return_desc": "<p>A pointer to the SimpleMenuLayer. NULL if the SimpleMenuLayer could not be created </p>", 
        "returns": "SimpleMenuLayer *", 
        "warning": "<p>The sections array is not deep-copied and can therefore not be stack allocated, but needs to be backed by long-lived storage. </p><p>This function does not add the menu's layer to the window. </p>", 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": "<p>The frame at which to initialize the menu </p>"
            }, 
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window onto which to set the click configuration provider </p>"
            }, 
            {
                "type": "SimpleMenuSection", 
                "name": "sections", 
                "description": "<p>Array with sections that need to be displayed in the menu </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "num_sections", 
                "description": "<p>The number of sections in the sections array. </p>"
            }, 
            {
                "type": "void *", 
                "name": "callback_context", 
                "description": "<p>Pointer to application specific data, that is passed into the callbacks. </p>"
            }
        ], 
        "description": "<p>Creates a new SimpleMenuLayer on the heap and initializes it. It also sets the internal click configuration provider onto given window."
    }, 
    "AppMessageInboxReceived": {
        "kind": "typedef", 
        "name": "AppMessageInboxReceived", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Called after an incoming message is received.</p><p>"
    }, 
    "bitmap_layer_set_background_color": {
        "kind": "fn", 
        "name": "bitmap_layer_set_background_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": "<p>The BitmapLayer for which to set the background color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": "<p>The new GColor to set the background to </p>"
            }
        ], 
        "description": "<p>Sets the background color of bounding box that will be drawn behind the image of the BitmapLayer.</p><p>The bitmap layer is automatically marked dirty after this operation."
    }, 
    "dict_write_end": {
        "kind": "fn", 
        "name": "dict_write_end", 
        "return_desc": "<p>The size in bytes of the finalized dictionary, or 0 if the parameters were invalid. </p>", 
        "returns": "uint32_t", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }
        ], 
        "description": "<p>End a series of writing operations to a dictionary. This must be called before reading back from the dictionary."
    }, 
    "dict_write_begin": {
        "kind": "fn", 
        "name": "dict_write_begin", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "uint8_t *const", 
                "name": "buffer", 
                "description": "<p>The storage of the dictionary </p>"
            }, 
            {
                "type": "const uint16_t", 
                "name": "size", 
                "description": "<p>The storage size of the dictionary </p>"
            }
        ], 
        "description": "<p>Initializes the dictionary iterator with a given buffer and size, resets and empties it, in preparation of writing key/value tuples. \n</p>"
    }, 
    "simple_menu_layer_destroy": {
        "kind": "fn", 
        "name": "simple_menu_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "SimpleMenuLayer *", 
                "name": "menu_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a SimpleMenuLayer previously created by <code>simple_menu_layer_create</code>. </p>"
    }, 
    "SimpleMenuLayer": {
        "kind": "typedef", 
        "name": "SimpleMenuLayer", 
        "return_desc": null, 
        "returns": "struct SimpleMenuLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "grect_standardize": {
        "kind": "fn", 
        "name": "grect_standardize", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The standardized rectangle. </p>"
            }
        ], 
        "description": "<p>Converts a rectangle's values so that the components of its size (width and/or height) are both positive. In the width and/or height are negative, the origin will offset, so that the final rectangle overlaps with the original. For example, a GRect with size (-10, -5) and origin (20, 20), will be standardized to size (10, 5) and origin (10, 15)."
    }, 
    "clock_copy_time_string": {
        "kind": "fn", 
        "name": "clock_copy_time_string", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>AM/PM are also outputted with the time if the user's preference is 12h time. </p>", 
        "params": [
            {
                "type": "char *", 
                "name": "buffer", 
                "description": "<p>A pointer to the buffer to copy the time string into </p>"
            }, 
            {
                "type": "uint8_t", 
                "name": "size", 
                "description": "<p>The maximum size of buffer </p>"
            }
        ], 
        "description": "<p>Copies a time string into the buffer, formatted according to the user's time display preferences (such as 12h/24h time). Example results: \"7:30\" or \"15:00\"."
    }, 
    "menu_layer_set_click_config_onto_window": {
        "kind": "fn", 
        "name": "menu_layer_set_click_config_onto_window", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>The MenuLayer that needs to receive click events. </p>"
            }, 
            {
                "type": "struct Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the click configuration. </p>"
            }
        ], 
        "description": "<p>Convenience function to set the ClickConfigProvider callback on the given window to menu layer's internal click config provider. This internal click configuration provider, will set up the default UP & DOWN scrolling / menu item selection behavior. This function calls <code>scroll_layer_set_click_config_onto_window</code> to accomplish this.</p><p>Click and long click events for the SELECT button can be handled by installing the appropriate callbacks using <code>menu_layer_set_callbacks()</code>. This is a deviation from the usual click configuration provider pattern. \n</p>"
    }, 
    "GCornersBottom": {
        "kind": "enum", 
        "name": "GCornersBottom", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Bottom corners. </p>"
    }, 
    "ClickHandler": {
        "kind": "typedef", 
        "name": "ClickHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of the callback that handles a recognized click pattern \n</p>"
    }, 
    "layer_set_clips": {
        "kind": "fn", 
        "name": "layer_set_clips", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to set the clipping property </p>"
            }, 
            {
                "type": "bool", 
                "name": "clips", 
                "description": "<p>Supply true to make the layer clip to its frame, or false to make it non-clipping. </p>"
            }
        ], 
        "description": "<p>Sets whether clipping is enabled for the layer. If enabled, whatever the layer and its children will draw using their .<code>update_proc</code> callbacks, will be clipped by the this layer's frame. If the clipping has changed, <code>layer_mark_dirty()</code> will be called automatically."
    }, 
    "APP_MSG_OK": {
        "kind": "enum", 
        "name": "APP_MSG_OK", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>All good, operation was successful. </p>"
    }, 
    "GRectSetter": {
        "kind": "typedef", 
        "name": "GRectSetter", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of a setter function to set a property of type GRect onto the subject. \n</p>"
    }, 
    "GPointReturn": {
        "kind": "typedef", 
        "name": "GPointReturn", 
        "return_desc": null, 
        "returns": "GPoint", 
        "warning": null, 
        "params": [], 
        "description": "<p>Work-around for function pointer return type GPoint avoid tripping the pre-processor to use the equally named GPoint define </p>"
    }, 
    "accel_data_service_unsubscribe": {
        "kind": "fn", 
        "name": "accel_data_service_unsubscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unsubscribe from the accelerometer data event service. Once unsubscribed, the previously registered handler will no longer be called. </p>"
    }, 
    "dict_write_int": {
        "kind": "fn", 
        "name": "dict_write_int", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>There is no checking for duplicate keys. </p>", 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key </p>"
            }, 
            {
                "type": "const void *", 
                "name": "integer", 
                "description": "<p>Pointer to the integer value </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "width_bytes", 
                "description": "<p>The width of the integer value </p>"
            }, 
            {
                "type": "const bool", 
                "name": "is_signed", 
                "description": "<p>Whether the integer's type is signed or not </p>"
            }
        ], 
        "description": "<p>Adds a key with an integer value pair to the dictionary."
    }, 
    "accel_service_peek": {
        "kind": "fn", 
        "name": "accel_service_peek", 
        "return_desc": "<p>-1 if the accel is not running </p><p>-2 if subscribed to accelerometer events. </p>", 
        "returns": "int", 
        "warning": "<p>Cannot be used when subscribed to accelerometer data events. </p>", 
        "params": [
            {
                "type": "AccelData *", 
                "name": "data", 
                "description": "<p>a pointer to a pre-allocated AccelData item </p>"
            }
        ], 
        "description": "<p>Peek at the last recorded reading."
    }, 
    "PropertyAnimationAccessors": {
        "kind": "typedef", 
        "name": "PropertyAnimationAccessors", 
        "return_desc": null, 
        "returns": "PropertyAnimationAccessors", 
        "warning": null, 
        "params": [], 
        "description": "<p>Data structure containing the setter and getter function pointers that the property animation should use. The specified setter function will be used by the animation's update callback. \n Based on the type of the property (<code>int16_t</code>, GPoint or GRect), the accompanying update callback should be used, see <code>property_animation_update_int16()</code>, <code>property_animation_update_gpoint()</code> and <code>property_animation_update_grect()</code>. \n The getter function is used when the animation is initialized, to assign the current value of the subject's property as \"from\" or \"to\" value, see <code>property_animation_create()</code>. </p>"
    }, 
    "layer_add_child": {
        "kind": "fn", 
        "name": "layer_add_child", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "parent", 
                "description": "<p>The layer to which to add the child layer </p>"
            }, 
            {
                "type": "Layer *", 
                "name": "child", 
                "description": "<p>The layer to add to the parent layer </p>"
            }
        ], 
        "description": "<p>Adds the child layer to a given parent layer, making it appear in front of its parent and in front of any existing child layers of the parent. If the child layer was already part of a layer hierarchy, it will be removed from its old parent first. If added successfully, the parent (and children) will be marked dirty automatically."
    }, 
    "APP_MSG_BUSY": {
        "kind": "enum", 
        "name": "APP_MSG_BUSY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>There are pending (in or outbound) messages that need to be processed first before new ones can be received or sent. </p>"
    }, 
    "TRIG_MAX_RATIO": {
        "kind": "def", 
        "name": "TRIG_MAX_RATIO", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The largest value that can result from a call to <code>sin_lookup</code> or <code>cos_lookup</code>. For a code example, see the detailed description at the top of this chapter: Math </p>"
    }, 
    "property_animation_create_layer_frame": {
        "kind": "fn", 
        "name": "property_animation_create_layer_frame", 
        "return_desc": "<p>A pointer to the property animation. NULL if animation could not be created </p>", 
        "returns": "PropertyAnimation", 
        "warning": "<p>Pass in NULL as one of the frame arguments to have it set automatically to the layer's current frame. This will result in a call to <code>layer_get_frame()</code> to get the current frame of the layer. </p>", 
        "params": [
            {
                "type": "struct Layer *", 
                "name": "layer", 
                "description": "<p>the layer that will be animated </p>"
            }, 
            {
                "type": "GRect", 
                "name": "from_frame", 
                "description": "<p>the frame that the layer should animate from </p>"
            }, 
            {
                "type": "GRect", 
                "name": "to_frame", 
                "description": "<p>the frame that the layer should animate to </p>"
            }
        ], 
        "description": "<p>Convenience function to create and initialize a property animation that animates the frame of a Layer. It sets up the PropertyAnimation to use <code>layer_set_frame()</code> and <code>layer_get_frame()</code> as accessors and uses the layer parameter as the subject for the animation. The same defaults are used as with <code>animation_create()</code>."
    }, 
    "window_stack_contains_window": {
        "kind": "fn", 
        "name": "window_stack_contains_window", 
        "return_desc": "<p>true if the window is currently on the window stack. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window to look for on the window stack </p>"
            }
        ], 
        "description": "<p>Checks if the window is on the window stack"
    }, 
    "rot_bitmap_layer_increment_angle": {
        "kind": "fn", 
        "name": "rot_bitmap_layer_increment_angle", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "RotBitmapLayer *", 
                "name": "image", 
                "description": null
            }, 
            {
                "type": "int32_t", 
                "name": "angle_change", 
                "description": null
            }
        ], 
        "description": "<p>changes the rotation by the given amount </p>"
    }, 
    "dict_write_int8": {
        "kind": "fn", 
        "name": "dict_write_int8", 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": null
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": null
            }, 
            {
                "type": "const int8_t", 
                "name": "value", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "scroll_layer_create": {
        "kind": "fn", 
        "name": "scroll_layer_create", 
        "return_desc": "<p>A pointer to the ScrollLayer. NULL if the ScrollLayer could not be created </p>", 
        "returns": "ScrollLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": null
            }
        ], 
        "description": "<p>Creates a new ScrollLayer on the heap and initalizes it with the default values:<ul><li><p>Clips: true</p></li><li><p>Hidden: false</p></li><li><p>Content size: frame.size</p></li><li><p>Content offset: GPointZero</p></li><li><p>Callbacks: None (NULL for each one)</p></li><li><p>Callback context: NULL </li></ul>\n</p>"
    }, 
    "MenuLayerGetCellHeightCallback": {
        "kind": "typedef", 
        "name": "MenuLayerGetCellHeightCallback", 
        "return_desc": "<p>The height of the cell at the given MenuIndex </p>", 
        "returns": "int16_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to get the height of the menu cell at a given index. \n</p>"
    }, 
    "DATA_LOGGING_NOT_FOUND": {
        "kind": "enum", 
        "name": "DATA_LOGGING_NOT_FOUND", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The logging session does not exist. </p>"
    }, 
    "MenuLayerGetNumberOfSectionsCallback": {
        "kind": "typedef", 
        "name": "MenuLayerGetNumberOfSectionsCallback", 
        "return_desc": "<p>The number of sections in the menu </p>", 
        "returns": "uint16_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to get the number of sections in a menu. \n</p>"
    }, 
    "app_message_outbox_send": {
        "kind": "fn", 
        "name": "app_message_outbox_send", 
        "return_desc": "<p>A result code, including but not limited to <code>APP_MSG_OK</code> or <code>APP_MSG_BUSY</code>. The <code>APP_MSG_OK</code> code does not mean that the message was sent successfully, but only that the start of processing was successful. Since this call is asynchronous, callbacks provide the final result instead.</p>", 
        "returns": "AppMessageResult", 
        "warning": null, 
        "params": [], 
        "description": "<p>Sends the outbound dictionary.</p><p>\n</p>"
    }, 
    "layer_remove_from_parent": {
        "kind": "fn", 
        "name": "layer_remove_from_parent", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "child", 
                "description": "<p>The layer to remove </p>"
            }
        ], 
        "description": "<p>Removes the layer from its current parent layer If removed successfully, the child's parent layer will be marked dirty automatically."
    }, 
    "APP_MSG_OUT_OF_MEMORY": {
        "kind": "enum", 
        "name": "APP_MSG_OUT_OF_MEMORY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The support library did not have sufficient application memory to perform the requested operation. </p>"
    }, 
    "accel_tap_service_subscribe": {
        "kind": "fn", 
        "name": "accel_tap_service_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "AccelTapHandler", 
                "name": "handler", 
                "description": "<p>A callback to be executed on tap event </p>"
            }
        ], 
        "description": "<p>Subscribe to the accelerometer tap event service. Once subscribed, the handler gets called on every tap event emitted by the accelerometer."
    }, 
    "Tuplet": {
        "kind": "typedef", 
        "name": "Tuplet", 
        "return_desc": null, 
        "returns": "Tuplet", 
        "warning": null, 
        "params": [], 
        "description": "<p>Non-serialized, template data structure for a key/value pair. For strings and byte arrays, it only has a pointer to the actual data. For integers, it provides storage for integers up to 32-bits wide. The Tuplet data structure is useful when creating dictionaries from values that are already stored in arbitrary buffers. See also Tuple, with is the header of a serialized key/value pair. </p>"
    }, 
    "gpath_destroy": {
        "kind": "fn", 
        "name": "gpath_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GPath", 
                "name": "gpath", 
                "description": null
            }
        ], 
        "description": "<p>Free a dynamically allocated gpath created with <code>gpath_create()</code> </p>"
    }, 
    "GCompOpClear": {
        "kind": "enum", 
        "name": "GCompOpClear", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Clears the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is white, the destination image will be painted black. Other parts will be left untouched. </p>"
    }, 
    "action_bar_layer_create": {
        "kind": "fn", 
        "name": "action_bar_layer_create", 
        "return_desc": "<p>A pointer to the ActionBarLayer. NULL if the ActionBarLayer could not be created </p>", 
        "returns": "ActionBarLayer *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Creates a new ActionBarLayer on the heap and initalizes it with the default values.<ul><li><p>Background color: GColorBlack</p></li><li><p>No click configuration provider (NULL)</p></li><li><p>No icons</p></li><li><p>Not added to / associated with any window, thus not catching any button input yet. </li></ul>\n</p>"
    }, 
    "DAY_UNIT": {
        "kind": "enum", 
        "name": "DAY_UNIT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Flag to represent the \"days\" time unit. </p>"
    }, 
    "GAlignBottomLeft": {
        "kind": "enum", 
        "name": "GAlignBottomLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the bottom edges overlap and left edges overlap. </p>"
    }, 
    "window_stack_push": {
        "kind": "fn", 
        "name": "window_stack_push", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window to push on top </p>"
            }, 
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>Pass in true to animate the push using a sliding animation, or false to skip the animation. </p>"
            }
        ], 
        "description": "<p>Pushes the given window on the window navigation stack, on top of the current topmost window of the app."
    }, 
    "accel_service_set_sampling_rate": {
        "kind": "fn", 
        "name": "accel_service_set_sampling_rate", 
        "return_desc": null, 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "AccelSamplingRate", 
                "name": "rate", 
                "description": "<p>The sampling rate in Hz (10Hz, 25Hz, 50Hz, and 100Hz possible) </p>"
            }
        ], 
        "description": "<p>Change the accelerometer sampling rate."
    }, 
    "click_number_of_clicks_counted": {
        "kind": "fn", 
        "name": "click_number_of_clicks_counted", 
        "return_desc": "<p>The number of consecutive clicks, and for auto-repeating the number of repetitions. </p>", 
        "returns": "uint8_t", 
        "warning": null, 
        "params": [
            {
                "type": "ClickRecognizerRef", 
                "name": "recognizer", 
                "description": "<p>The click recognizer for which to get the click count </p>"
            }
        ], 
        "description": "<p>Gets the click count. You can use this inside a click handler implementation to get the click count for <code>multi_click</code> and (repeated) click events."
    }, 
    "E_UNKNOWN": {
        "kind": "enum", 
        "name": "E_UNKNOWN", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>No idea what went wrong. </p>"
    }, 
    "MONTH_UNIT": {
        "kind": "enum", 
        "name": "MONTH_UNIT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Flag to represent the \"months\" time unit. </p>"
    }, 
    "animation_set_implementation": {
        "kind": "fn", 
        "name": "animation_set_implementation", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation for which to set the implementation. </p>"
            }, 
            {
                "type": "AnimationImplementation", 
                "name": "implementation", 
                "description": "<p>The structure with function pointers to the implementation of the setup, update and teardown functions. </p>"
            }
        ], 
        "description": "<p>Sets the implementation of the custom animation. When implementing custom animations, use this function to specify what functions need to be called to for the setup, frame update and teardown of the animation. \n</p>"
    }, 
    "dict_read_first": {
        "kind": "fn", 
        "name": "dict_read_first", 
        "return_desc": "<p>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </p>", 
        "returns": "Tuple *", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }
        ], 
        "description": "<p>Resets the iterator back to the same state as a call to <code>dict_read_begin_from_buffer()</code> would do."
    }, 
    "APP_MSG_CALLBACK_NOT_REGISTERED": {
        "kind": "enum", 
        "name": "APP_MSG_CALLBACK_NOT_REGISTERED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The callback could not be deregistered, because it had not been registered before. </p>"
    }, 
    "menu_cell_title_draw": {
        "kind": "fn", 
        "name": "menu_cell_title_draw", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context </p>"
            }, 
            {
                "type": "const Layer *", 
                "name": "cell_layer", 
                "description": "<p>The layer of the cell to draw </p>"
            }, 
            {
                "type": "const char *", 
                "name": "title", 
                "description": "<p>If non-null, draws a title in larger text (28 points, bold Raster Gothic system font). </p>"
            }
        ], 
        "description": "<p>Cell drawing function to draw a basic menu cell layout with title, subtitle Cell drawing function to draw a menu cell layout with only one big title. Call this function inside the .<code>draw_row</code> callback implementation, see MenuLayerCallbacks."
    }, 
    "window_set_click_config_provider": {
        "kind": "fn", 
        "name": "window_set_click_config_provider", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the click config provider </p>"
            }, 
            {
                "type": "ClickConfigProvider", 
                "name": "click_config_provider", 
                "description": "<p>The callback that will be called to configure the click recognizers with the window </p>"
            }
        ], 
        "description": "<p>Sets the click configuration provider callback function on the window. This will automatically setup the input handlers of the window as well to use the click recognizer subsystem. \n</p>"
    }, 
    "GContext": {
        "kind": "typedef", 
        "name": "GContext", 
        "return_desc": null, 
        "returns": "struct GContext", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "GAlignBottomRight": {
        "kind": "enum", 
        "name": "GAlignBottomRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the bottom edges overlap and right edges overlap. </p>"
    }, 
    "AppSyncErrorCallback": {
        "kind": "typedef", 
        "name": "AppSyncErrorCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Called whenever there was an error. \n</p>"
    }, 
    "GPointGetter": {
        "kind": "typedef", 
        "name": "GPointGetter", 
        "return_desc": null, 
        "returns": "GPointReturn", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of a getter function to get the current property of type GPoint of the subject. \n</p>"
    }, 
    "inverter_layer_create": {
        "kind": "fn", 
        "name": "inverter_layer_create", 
        "return_desc": "<p>A pointer to the InverterLayer. NULL if the InverterLayer could not be created </p>", 
        "returns": "InverterLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": null
            }
        ], 
        "description": "<p>Creates a new InverterLayer on the heap and initializes it with the default values.<ul><li><p>Clips: true</p></li><li><p>Hidden: false </li></ul>\n</p>"
    }, 
    "layer_set_update_proc": {
        "kind": "fn", 
        "name": "layer_set_update_proc", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": "<p>Pointer to the layer structure. </p>"
            }, 
            {
                "type": "LayerUpdateProc", 
                "name": "update_proc", 
                "description": "<p>Pointer to the function that will be called when the layer needs to be rendered. Typically, one performs a series of drawing commands in the implementation of the <code>update_proc</code>, see Drawing Primitives, Drawing Paths and Drawing Text. </p>"
            }
        ], 
        "description": "<p>Sets the layer's render function. The system will call the <code>update_proc</code> automatically when the layer needs to redraw itself, see also <code>layer_mark_dirty()</code>."
    }, 
    "gpath_create": {
        "kind": "fn", 
        "name": "gpath_create", 
        "return_desc": "<p>A pointer to the GPath. NULL if the GPath could not be created </p>", 
        "returns": "GPath", 
        "warning": null, 
        "params": [
            {
                "type": "GPathInfo", 
                "name": "init", 
                "description": null
            }
        ], 
        "description": "<p>Creates a new GPath on the heap based on a series of points described by a GPathInfo.</p><p>Values after initialization:<ul><li><p><code>num_points</code> and points pointer: copied from the GPathInfo.</p></li><li><p>rotation: 0</p></li><li><p>offset: (0, 0) </li></ul>\n</p>"
    }, 
    "GCornersRight": {
        "kind": "enum", 
        "name": "GCornersRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Right corners. </p>"
    }, 
    "app_message_register_inbox_dropped": {
        "kind": "fn", 
        "name": "app_message_register_inbox_dropped", 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageInboxDropped", 
        "warning": null, 
        "params": [
            {
                "type": "AppMessageInboxDropped", 
                "name": "dropped_callback", 
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>"
            }
        ], 
        "description": "<p>Registers a function that will be called after any Inbox message is received but dropped by the system.</p><p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>"
    }, 
    "MENU_INDEX_NOT_FOUND": {
        "kind": "def", 
        "name": "MENU_INDEX_NOT_FOUND", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "number_window_set_value": {
        "kind": "fn", 
        "name": "number_window_set_value", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "NumberWindow *", 
                "name": "numberwindow", 
                "description": "<p>Pointer to the NumberWindow for which to set the current value </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "value", 
                "description": "<p>The new current value </p>"
            }
        ], 
        "description": "<p>Sets the current value of the field"
    }, 
    "layer_set_bounds": {
        "kind": "fn", 
        "name": "layer_set_bounds", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to set the bounds </p>"
            }, 
            {
                "type": "GRect", 
                "name": "bounds", 
                "description": "<p>The new bounds </p>"
            }
        ], 
        "description": "<p>Sets the bounds of the layer, which is it's bounding box relative to its frame. If the bounds has changed, <code>layer_mark_dirty()</code> will be called automatically. \n</p>"
    }, 
    "bitmap_layer_set_alignment": {
        "kind": "fn", 
        "name": "bitmap_layer_set_alignment", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": "<p>The BitmapLayer for which to set the aligment </p>"
            }, 
            {
                "type": "GAlign", 
                "name": "alignment", 
                "description": "<p>The new alignment for the image inside the BitmapLayer </p>"
            }
        ], 
        "description": "<p>Sets the alignment of the image to draw with in frame of the BitmapLayer. The aligment parameter specifies which edges of the bitmap should overlap with the frame of the BitmapLayer. If the bitmap is smaller than the frame of the BitmapLayer, the background is filled with the background color.</p><p>The bitmap layer is automatically marked dirty after this operation."
    }, 
    "APP_MSG_SEND_REJECTED": {
        "kind": "enum", 
        "name": "APP_MSG_SEND_REJECTED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The other end rejected the sent data, with a \"nack\" reply. </p>"
    }, 
    "ResHandle": {
        "kind": "typedef", 
        "name": "ResHandle", 
        "return_desc": null, 
        "returns": "const void *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Opaque reference to a resource. \n</p>"
    }, 
    "menu_index_compare": {
        "kind": "fn", 
        "name": "menu_index_compare", 
        "return_desc": "<p>0 if A and B are equal, 1 if A has a higher section & row combination than B or else -1 </p>", 
        "returns": "int16_t", 
        "warning": null, 
        "params": [
            {
                "type": "MenuIndex", 
                "name": "a", 
                "description": "<p>Pointer to the menu index of the first item </p>"
            }, 
            {
                "type": "MenuIndex", 
                "name": "b", 
                "description": "<p>Pointer to the menu index of the second item </p>"
            }
        ], 
        "description": "<p>Comparator function to determine the order of two MenuIndex values."
    }, 
    "accel_service_set_samples_per_update": {
        "kind": "fn", 
        "name": "accel_service_set_samples_per_update", 
        "return_desc": null, 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "uint32_t", 
                "name": "num_samples", 
                "description": "<p>the number of samples to buffer, between 0 and 25. </p>"
            }
        ], 
        "description": "<p>Change the number of samples buffered between each accelerometer data event"
    }, 
    "gpoint_equal": {
        "kind": "fn", 
        "name": "gpoint_equal", 
        "return_desc": "<p>true if both points are equal, false if not. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "GPoint", 
                "name": "point_a", 
                "description": "<p>Pointer to the first point </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "point_b", 
                "description": "<p>Pointer to the second point </p>"
            }
        ], 
        "description": "<p>Tests whether 2 points are equal."
    }, 
    "GTextLayoutCacheRef": {
        "kind": "typedef", 
        "name": "GTextLayoutCacheRef", 
        "return_desc": null, 
        "returns": "TextLayout *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Pointer to opaque text layout cache data structure. </p>"
    }, 
    "E_RANGE": {
        "kind": "enum", 
        "name": "E_RANGE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Argument out of range (may be dynamic). </p>"
    }, 
    "GCompOpAssign": {
        "kind": "enum", 
        "name": "GCompOpAssign", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Assign the pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p>"
    }, 
    "psleep": {
        "kind": "fn", 
        "name": "psleep", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "int", 
                "name": "millis", 
                "description": "<p>The number of milliseconds to wait for </p>"
            }
        ], 
        "description": "<p>Waits for a certain amount of milliseconds"
    }, 
    "TupletInteger": {
        "kind": "def", 
        "name": "TupletInteger", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "GCornerBottomLeft": {
        "kind": "enum", 
        "name": "GCornerBottomLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Bottom-Left corner. </p>"
    }, 
    "AnimationTeardownImplementation": {
        "kind": "typedef", 
        "name": "AnimationTeardownImplementation", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Pointer to function that (optionally) cleans up the animation. This callback is called when the animation is removed from the scheduler. In case the .setup implementation allocated any memory, this is a good place to release that memory again. \n</p>"
    }, 
    "DATA_LOGGING_BYTE_ARRAY": {
        "kind": "enum", 
        "name": "DATA_LOGGING_BYTE_ARRAY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Array of bytes. Remember that this is the type of a single item in the logging session, so using this type means you'll be logging multiple byte arrays (each a fixed length described by <code>item_length</code>) for the duration of the session. </p>"
    }, 
    "PERSIST_DATA_MAX_LENGTH": {
        "kind": "def", 
        "name": "PERSIST_DATA_MAX_LENGTH", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The maximum size of a persist value in bytes. </p>"
    }, 
    "ListNode": {
        "kind": "typedef", 
        "name": "ListNode", 
        "return_desc": null, 
        "returns": "ListNode", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "window_single_click_subscribe": {
        "kind": "fn", 
        "name": "window_single_click_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p><p><code>window_single_click_subscribe()</code> and <code>window_single_repeating_click_subscribe()</code> conflict, and cannot both be used on the same button. </p>", 
        "params": [
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The button events to subscribe to. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "handler", 
                "description": "<p>The ClickHandler to fire on this event. </p>"
            }
        ], 
        "description": "<p>Subscribe to single click events. A single click is detected every time \"<code>repeat_interval_ms</code>\" has been reached. <p>When there is a <code>multi_click</code> and/or <code>long_click</code> setup, there will be a delay pending before the single click handler will get fired. On the other hand, when there is no <code>multi_click</code> nor <code>long_click</code> setup, the single click handler will fire directly on button down. </p>\n\n</p>"
    }, 
    "animation_create": {
        "kind": "fn", 
        "name": "animation_create", 
        "return_desc": "<p>A pointer to the animation. NULL if the animation could not be created </p>", 
        "returns": "Animation", 
        "warning": null, 
        "params": [], 
        "description": "<p>Creates a new Animation on the heap and initalizes it with the default values.</p><p><ul><li><p>Duration: 250ms,</p></li><li><p>Curve: AnimationCurveEaseInOut (ease-in-out),</p></li><li><p>Delay: 0ms,</p></li><li><p>Handlers: {NULL, NULL} (none),</p></li><li><p>Context: NULL (none),</p></li><li><p>Implementation: NULL (no implementation),</p></li><li><p>Scheduled: no </li></ul>\n</p>"
    }, 
    "GColorBlack": {
        "kind": "enum", 
        "name": "GColorBlack", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Represents black. </p>"
    }, 
    "menu_layer_get_layer": {
        "kind": "fn", 
        "name": "menu_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the menu layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "const MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>Pointer to the MenuLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the menu layer, which is the parent for the sub- layers used for its implementation."
    }, 
    "Layer": {
        "kind": "typedef", 
        "name": "Layer", 
        "return_desc": null, 
        "returns": "struct Layer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "app_sync_set": {
        "kind": "fn", 
        "name": "app_sync_set", 
        "return_desc": "<p>The result code from the AppMessage subsystem. Can be <code>APP_MSG_OK</code>, <code>APP_MSG_BUSY</code> or <code>APP_MSG_INVALID_ARGS</code> </p>", 
        "returns": "AppMessageResult", 
        "warning": "<p>The call will attempt to send the updated keys and values to the application on the other end. Only after the other end has acknowledged the update, the .<code>value_changed</code> callback will be called to confirm the update has completed and your application code can update its user interface. </p>", 
        "params": [
            {
                "type": "AppSync", 
                "name": "s", 
                "description": "<p>The AppSync context </p>"
            }, 
            {
                "type": "Tuplet", 
                "name": "keys_and_values_to_update", 
                "description": "<p>An array of Tuplets with the keys and values to update. The data in the Tuplets are copied during the call, so the array can be stack-allocated. </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "count", 
                "description": "<p>The number of Tuplets in the <code>keys_and_values_to_update</code> array. </p>"
            }
        ], 
        "description": "<p>Updates key/value pairs using an array of Tuplets."
    }, 
    "animation_set_delay": {
        "kind": "fn", 
        "name": "animation_set_delay", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation for which to set the delay. </p>"
            }, 
            {
                "type": "uint32_t", 
                "name": "delay_ms", 
                "description": "<p>The delay in milliseconds that the animation system should wait from the moment the animation is scheduled to starting the animation. </p>"
            }
        ], 
        "description": "<p>Sets an optional delay for the animation."
    }, 
    "text_layer_set_font": {
        "kind": "fn", 
        "name": "text_layer_set_font", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the font </p>"
            }, 
            {
                "type": "GFont", 
                "name": "font", 
                "description": "<p>The new GFont for the TextLayer </p>"
            }
        ], 
        "description": "<p>Sets the font of the TextLayer \n</p>"
    }, 
    "gbitmap_create_as_sub_bitmap": {
        "kind": "fn", 
        "name": "gbitmap_create_as_sub_bitmap", 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": null, 
        "params": [
            {
                "type": "const GBitmap *", 
                "name": "base_bitmap", 
                "description": "<p>The bitmap that the sub-bitmap of which the image data will be used by the sub-bitmap </p>"
            }, 
            {
                "type": "GRect", 
                "name": "sub_rect", 
                "description": "<p>The rectangle within the image data of the base bitmap. The bounds of the base bitmap will be used to clip <code>sub_rect</code>. </p>"
            }
        ], 
        "description": "<p>Create a new GBitmap on the heap as a sub-bitmap of a 'base' GBitmap, using a GRect to indicate what portion of the base to use. The sub-bitmap will just reference the image data of the base bitmap. No deep-copying occurs as a result of calling this function, thus the caller is responsible for making sure the base bitmap will remain available when using the sub-bitmap."
    }, 
    "GAlignTopLeft": {
        "kind": "enum", 
        "name": "GAlignTopLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the top edges overlap and left edges overlap. </p>"
    }, 
    "APP_LOG_LEVEL_DEBUG": {
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_DEBUG", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Debug level log message. </p>"
    }, 
    "MenuLayerGetHeaderHeightCallback": {
        "kind": "typedef", 
        "name": "MenuLayerGetHeaderHeightCallback", 
        "return_desc": "<p>The height of the section header at the given section index </p>", 
        "returns": "int16_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to get the height of the section header at a given section index. \n</p>"
    }, 
    "number_window_set_min": {
        "kind": "fn", 
        "name": "number_window_set_min", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "NumberWindow *", 
                "name": "numberwindow", 
                "description": "<p>Pointer to the NumberWindow for which to set the minimum value </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "min", 
                "description": "<p>The minimum value </p>"
            }
        ], 
        "description": "<p>Sets the minimum value this field can hold"
    }, 
    "Int16Getter": {
        "kind": "typedef", 
        "name": "Int16Getter", 
        "return_desc": null, 
        "returns": "int16_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of a getter function to get the current property of type <code>int16_t</code> of the subject. \n</p>"
    }, 
    "gbitmap_create_with_data": {
        "kind": "fn", 
        "name": "gbitmap_create_with_data", 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": null, 
        "params": [
            {
                "type": "const uint8_t *", 
                "name": "data", 
                "description": "<p>The Pebble image file data. Must not be NULL. The function assumes the data to be correct; there are no sanity checks performed on the data. </p>"
            }
        ], 
        "description": "<p>Creates a new GBitmap on the heap initialized with a Pebble image file data (.pbi), as output by bitmapgen.py."
    }, 
    "animation_set_handlers": {
        "kind": "fn", 
        "name": "animation_set_handlers", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation for which to set up the callbacks. </p>"
            }, 
            {
                "type": "AnimationHandlers", 
                "name": "callbacks", 
                "description": "<p>The callbacks. </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>A pointer to application specific data, that will be passed as an argument by the animation subsystem when a callback is called. </p>"
            }
        ], 
        "description": "<p>Sets the callbacks for the animation. Often an application needs to run code at the start or at the end of an animation. Using this function is possible to register callback functions with an animation, that will get called at the start and end of the animation."
    }, 
    "action_bar_layer_destroy": {
        "kind": "fn", 
        "name": "action_bar_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a ActionBarLayer previously created by <code>action_bar_layer_create</code>. </p>"
    }, 
    "BUTTON_ID_BACK": {
        "kind": "enum", 
        "name": "BUTTON_ID_BACK", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Back button. </p>"
    }, 
    "MenuLayer": {
        "kind": "typedef", 
        "name": "MenuLayer", 
        "return_desc": null, 
        "returns": "struct MenuLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "GTextOverflowModeFill": {
        "kind": "enum", 
        "name": "GTextOverflowModeFill", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Acts like GTextOverflowModeTrailingEllipsis, plus trims leading and trailing newlines, while treating all other newlines as spaces. </p>"
    }, 
    "layer_insert_above_sibling": {
        "kind": "fn", 
        "name": "layer_insert_above_sibling", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer_to_insert", 
                "description": "<p>The layer to insert into the hierarchy </p>"
            }, 
            {
                "type": "Layer *", 
                "name": "above_sibling_layer", 
                "description": "<p>The layer that will be used as the sibling layer below which the insertion will take place </p>"
            }
        ], 
        "description": "<p>Inserts the layer as a sibling in front of another layer. The <code>above_layer</code> has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically."
    }, 
    "AnimationImplementation": {
        "kind": "typedef", 
        "name": "AnimationImplementation", 
        "return_desc": null, 
        "returns": "AnimationImplementation", 
        "warning": "<p>The .setup callback is called immediately after scheduling the animation, regardless if there is a delay set for that animation using <code>animation_set_delay()</code>.</p>", 
        "params": [], 
        "description": "<p>The 3 callbacks that implement a custom animation. Only the .update callback is mandatory, .setup and .teardown are optional. See the documentation with the function pointer typedefs for more information.</p><p>\n</p><p>\n</p>"
    }, 
    "GCompOpAssignInverted": {
        "kind": "enum", 
        "name": "GCompOpAssignInverted", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Assign the inverted pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p>"
    }, 
    "NumberWindow": {
        "kind": "typedef", 
        "name": "NumberWindow", 
        "return_desc": null, 
        "returns": "struct NumberWindow", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "tick_timer_service_subscribe": {
        "kind": "fn", 
        "name": "tick_timer_service_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TimeUnits", 
                "name": "tick_units", 
                "description": "<p>the unit change we want to handle (seconds, minutes, hours) </p>"
            }, 
            {
                "type": "TickHandler", 
                "name": "handler", 
                "description": "<p>A callback to be executed on tick event </p>"
            }
        ], 
        "description": "<p>Subscribe to the tick timer event service. Once subscribed, the handler gets called on every requested unit change. Only\u00a0the\u00a0last\u00a0callback\u00a0and\u00a0settings\u00a0passed\u00a0will\u00a0be\u00a0used.\u00a0 This\u00a0can only be called once."
    }, 
    "number_window_create": {
        "kind": "fn", 
        "name": "number_window_create", 
        "return_desc": "<p>A pointer to the NumberWindow. NULL if the NumberWindow could not be created </p>", 
        "returns": "NumberWindow *", 
        "warning": "<p>The number window is not pushed to the window stack. Use <code>window_stack_push()</code> to do this. </p>", 
        "params": [
            {
                "type": "const char *", 
                "name": "label", 
                "description": "<p>The title or prompt to display in the NumberWindow. Must be long-lived and cannot be stack-allocated. </p>"
            }, 
            {
                "type": "NumberWindowCallbacks", 
                "name": "callbacks", 
                "description": "<p>The callbacks </p>"
            }, 
            {
                "type": "void *", 
                "name": "callback_context", 
                "description": "<p>Pointer to application specific data that is passed </p>"
            }
        ], 
        "description": "<p>Creates a new NumberWindow on the heap and initalizes it with the default values.</p><p>"
    }, 
    "dict_write_int16": {
        "kind": "fn", 
        "name": "dict_write_int16", 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": null
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": null
            }, 
            {
                "type": "const int16_t", 
                "name": "value", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "E_OUT_OF_RESOURCES": {
        "kind": "enum", 
        "name": "E_OUT_OF_RESOURCES", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Insufficient resources available. </p>"
    }, 
    "app_focus_service_subscribe": {
        "kind": "fn", 
        "name": "app_focus_service_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>In focus events are triggered when the app is no longer covered by a modal window. </p><p>Out focus events are triggered when the app becomes covered by a modal window. </p>", 
        "params": [
            {
                "type": "AppFocusHandler", 
                "name": "handler", 
                "description": "<p>A callback to be executed on in-focus events. </p>"
            }
        ], 
        "description": "<p>Subscribe to the focus event service. Once subscribed, the handler gets called every time the app focus changes."
    }, 
    "click_recognizer_get_button_id": {
        "kind": "fn", 
        "name": "click_recognizer_get_button_id", 
        "return_desc": "<p>the ButtonId of the click recognizer </p>", 
        "returns": "ButtonId", 
        "warning": null, 
        "params": [
            {
                "type": "ClickRecognizerRef", 
                "name": "recognizer", 
                "description": "<p>The click recognizer for which to get the button id that caused the click event </p>"
            }
        ], 
        "description": "<p>Gets the button identifier. You can use this inside a click handler implementation to get the button id for the click event."
    }, 
    "scroll_layer_set_content_size": {
        "kind": "fn", 
        "name": "scroll_layer_set_content_size", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to set the content size. </p>"
            }, 
            {
                "type": "GSize", 
                "name": "size", 
                "description": "<p>The new content size. </p>"
            }
        ], 
        "description": "<p>Sets the size of the contents layer. This determines the area that is scrollable. At the moment, this needs to be set \"manually\" and is not derived from the geometry of the contents layers. \n</p>"
    }, 
    "menu_layer_reload_data": {
        "kind": "fn", 
        "name": "menu_layer_reload_data", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>The MenuLayer for which to reload the data. </p>"
            }
        ], 
        "description": "<p>Reloads the data of the menu. This causes the menu to re-request the menu item data, by calling the relevant callbacks. The current selection and scroll position will not be changed. See the note with <code>menu_layer_set_selected_index()</code> for the behavior if the old selection is no longer valid."
    }, 
    "app_comm_get_sniff_interval": {
        "kind": "fn", 
        "name": "app_comm_get_sniff_interval", 
        "return_desc": "<p>The SniffInterval value corresponding to the current interval </p>", 
        "returns": "SniffInterval", 
        "warning": null, 
        "params": [], 
        "description": "<p>Get the Bluetooth module's sniff interval"
    }, 
    "menu_layer_get_selected_index": {
        "kind": "fn", 
        "name": "menu_layer_get_selected_index", 
        "return_desc": null, 
        "returns": "MenuIndex", 
        "warning": null, 
        "params": [
            {
                "type": "const MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>The MenuLayer for which to get the current selected index. </p>"
            }
        ], 
        "description": "<p>Gets the MenuIndex of the currently selection menu item."
    }, 
    "layer_get_clips": {
        "kind": "fn", 
        "name": "layer_get_clips", 
        "return_desc": "<p>True if clipping is enabled for the layer, false if clipping is not enabled for the layer. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "const Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to get the clipping property </p>"
            }
        ], 
        "description": "<p>Gets whether clipping is enabled for the layer. If enabled, whatever the layer and its children will draw using their .<code>update_proc</code> callbacks, will be clipped by the this layer's frame."
    }, 
    "graphics_context_set_text_color": {
        "kind": "fn", 
        "name": "graphics_context_set_text_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The graphics context onto which to set the text color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": "<p>The new text color </p>"
            }
        ], 
        "description": "<p>Sets the current text color of the graphics context."
    }, 
    "layer_set_hidden": {
        "kind": "fn", 
        "name": "layer_set_hidden", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to set the visibility </p>"
            }, 
            {
                "type": "bool", 
                "name": "hidden", 
                "description": "<p>Supply true to make the layer hidden, or false to make it non-hidden. </p>"
            }
        ], 
        "description": "<p>Sets the visibility of the layer. If the visibility has changed, <code>layer_mark_dirty()</code> will be called automatically on the parent layer."
    }, 
    "AnimationUpdateImplementation": {
        "kind": "typedef", 
        "name": "AnimationUpdateImplementation", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Pointer to function that updates the animation according to the given normalized time. This callback will be called repeatedly by the animation scheduler whenever the animation needs to be updated."
    }, 
    "SECOND_UNIT": {
        "kind": "enum", 
        "name": "SECOND_UNIT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Flag to represent the \"seconds\" time unit. </p>"
    }, 
    "APP_MSG_APP_NOT_RUNNING": {
        "kind": "enum", 
        "name": "APP_MSG_APP_NOT_RUNNING", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The local application was not running. </p>"
    }, 
    "simple_menu_layer_get_menu_layer": {
        "kind": "fn", 
        "name": "simple_menu_layer_get_menu_layer", 
        "return_desc": "<p>The MenuLayer. </p>", 
        "returns": "MenuLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "SimpleMenuLayer *", 
                "name": "simple_menu", 
                "description": "<p>The SimpleMenuLayer to get the MenuLayer from. </p>"
            }
        ], 
        "description": "<p>"
    }, 
    "window_is_loaded": {
        "kind": "fn", 
        "name": "window_is_loaded", 
        "return_desc": "<p>true if the window is currently loaded or false if not. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window to query its loaded status </p>"
            }
        ], 
        "description": "<p>Gets whether the window has been loaded. If a window is loaded, its .load handler has been called (and the .unload handler has not been called since). \n</p>"
    }, 
    "GPath": {
        "kind": "typedef", 
        "name": "GPath", 
        "return_desc": null, 
        "returns": "GPath", 
        "warning": "<p>See the remark with GPathInfo </p>", 
        "params": [], 
        "description": "<p>Data structure describing a path, plus its rotation and translation."
    }, 
    "GColorWhite": {
        "kind": "enum", 
        "name": "GColorWhite", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Represents white. </p>"
    }, 
    "animation_get_context": {
        "kind": "fn", 
        "name": "animation_get_context", 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null, 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation. </p>"
            }
        ], 
        "description": "<p>Gets the application-specific callback context of the animation. This void pointer is passed as an argument when the animation system calls AnimationHandlers callbacks. The context pointer can be set to point to any application specific data using <code>animation_set_handlers()</code>. \n</p>"
    }, 
    "MenuLayerGetSeparatorHeightCallback": {
        "kind": "typedef", 
        "name": "MenuLayerGetSeparatorHeightCallback", 
        "return_desc": "<p>The height of the separator at the given MenuIndex </p>", 
        "returns": "int16_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to get the height of the separator at a given index. \n</p>"
    }, 
    "grect_crop": {
        "kind": "fn", 
        "name": "grect_crop", 
        "return_desc": "<p>The cropped rectangle. </p>", 
        "returns": "GRect", 
        "warning": "<p>The function will trip an assertion if the crop yields a rectangle with negative width or height. </p>", 
        "params": [
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle that will be inset </p>"
            }, 
            {
                "type": "const int32_t", 
                "name": "crop_size_px", 
                "description": "<p>The inset by which each of the rectangle will be inset. A positive inset value results in a smaller rectangle, while negative inset value results in a larger rectangle. </p>"
            }
        ], 
        "description": "<p>Reduce the width and height of a rectangle by insetting each of the edges with a fixed inset. The returned rectangle will be centered relative to the input rectangle."
    }, 
    "APP_LOG_LEVEL_INFO": {
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_INFO", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Info level log message. </p>"
    }, 
    "StatusCode": {
        "kind": "typedef", 
        "name": "StatusCode", 
        "return_desc": null, 
        "returns": "enum StatusCode", 
        "warning": null, 
        "params": [], 
        "description": "<p>Status codes. </p>"
    }, 
    "graphics_fill_circle": {
        "kind": "fn", 
        "name": "graphics_fill_circle", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "p", 
                "description": "<p>The center point of the circle </p>"
            }, 
            {
                "type": "uint16_t", 
                "name": "radius", 
                "description": "<p>The radius in pixels </p>"
            }
        ], 
        "description": "<p>Fills a circle in the current fill color"
    }, 
    "Dictionary": {
        "kind": "typedef", 
        "name": "Dictionary", 
        "return_desc": null, 
        "returns": "struct Dictionary", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "menu_layer_destroy": {
        "kind": "fn", 
        "name": "menu_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "MenuLayer *", 
                "name": "menu_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a MenuLayer previously created by <code>menu_layer_create</code>. </p>"
    }, 
    "APP_LOG_LEVEL_DEBUG_VERBOSE": {
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_DEBUG_VERBOSE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Verbose Debug level log message. </p>"
    }, 
    "battery_state_service_unsubscribe": {
        "kind": "fn", 
        "name": "battery_state_service_unsubscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unsubscribe from the battery state event service. Once unsubscribed, the previously registered handler will no longer be called. </p>"
    }, 
    "PERSIST_STRING_MAX_LENGTH": {
        "kind": "def", 
        "name": "PERSIST_STRING_MAX_LENGTH", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The maximum size of a persist string in bytes including the NULL terminator. </p>"
    }, 
    "GFont": {
        "kind": "typedef", 
        "name": "GFont", 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Pointer to opaque font data structure. \n</p>"
    }, 
    "sin_lookup": {
        "kind": "fn", 
        "name": "sin_lookup", 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null, 
        "params": [
            {
                "type": "int32_t", 
                "name": "angle", 
                "description": "<p>The angle for which to compute the cosine. The angle value is scaled linearly, such that a value of 0x10000 corresponds to 360 degrees or 2 PI radians. </p>"
            }
        ], 
        "description": "<p>Look-up the sine of the given angle from a pre-computed table."
    }, 
    "bitmap_layer_get_bitmap": {
        "kind": "fn", 
        "name": "bitmap_layer_get_bitmap", 
        "return_desc": "<p>A pointer to the bitmap image that the BitmapLayer is using </p>", 
        "returns": "const GBitmap *", 
        "warning": null, 
        "params": [
            {
                "type": "BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": "<p>The BitmapLayer for which to get the bitmap image </p>"
            }
        ], 
        "description": "<p>Gets the pointer to the bitmap image that the BitmapLayer is using.</p><p>"
    }, 
    "APP_MSG_SEND_TIMEOUT": {
        "kind": "enum", 
        "name": "APP_MSG_SEND_TIMEOUT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The other end did not confirm receiving the sent data with an (n)ack in time. </p>"
    }, 
    "E_INTERNAL": {
        "kind": "enum", 
        "name": "E_INTERNAL", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>There was a generic internal logic error. </p>"
    }, 
    "bitmap_layer_get_layer": {
        "kind": "fn", 
        "name": "bitmap_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the bitmap layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "const BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": "<p>Pointer to the BitmapLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the bitmap layer, which is the parent for the sub- layers used for its implementation."
    }, 
    "animation_unschedule_all": {
        "kind": "fn", 
        "name": "animation_unschedule_all", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unschedules all animations of the application. \n</p>"
    }, 
    "MenuLayerDrawSeparatorCallback": {
        "kind": "typedef", 
        "name": "MenuLayerDrawSeparatorCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>The <code>cell_layer</code> argument is provided to make it easy to re-use an .<code>update_proc</code> implementation in this callback. Only the bounds and frame of the <code>cell_layer</code> are actually valid and other properties should be ignored. </p>", 
        "params": [], 
        "description": "<p>Function signature for the callback to render the separator at a given MenuIndex. \n</p>"
    }, 
    "light_enable_interaction": {
        "kind": "fn", 
        "name": "light_enable_interaction", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Trigger the backlight and schedule a timer to automatically disable the backlight after a short delay. This is the preferred method of interacting with the backlight. </p>"
    }, 
    "bluetooth_connection_service_subscribe": {
        "kind": "fn", 
        "name": "bluetooth_connection_service_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BluetoothConnectionHandler", 
                "name": "handler", 
                "description": "<p>A callback to be executed on connection event </p>"
            }
        ], 
        "description": "<p>Subscribe to the bluetooth event service. Once subscribed, the handler gets called on every bluetooth connection event."
    }, 
    "dict_find": {
        "kind": "fn", 
        "name": "dict_find", 
        "return_desc": "<p>Pointer to a found Tuple, or NULL if there was no Tuple with the specified key. </p>", 
        "returns": "Tuple *", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>Iterator to the dictionary to search in. </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key for which to find a Tuple </p>"
            }
        ], 
        "description": "<p>Tries to find a Tuple with specified key in a dictionary"
    }, 
    "DATA_LOGGING_INT": {
        "kind": "enum", 
        "name": "DATA_LOGGING_INT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Signed integer. This may be a 1, 2, or 4 byte integer depending on the <code>item_length</code> parameter. </p>"
    }, 
    "DATA_LOGGING_SUCCESS": {
        "kind": "enum", 
        "name": "DATA_LOGGING_SUCCESS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Successful operation. </p>"
    }, 
    "rot_bitmap_layer_set_corner_clip_color": {
        "kind": "fn", 
        "name": "rot_bitmap_layer_set_corner_clip_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "RotBitmapLayer *", 
                "name": "image", 
                "description": null
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "WindowHandlers": {
        "kind": "typedef", 
        "name": "WindowHandlers", 
        "return_desc": null, 
        "returns": "WindowHandlers", 
        "warning": null, 
        "params": [], 
        "description": "<p>WindowHandlers These handlers are called by the Window Stack as windows get pushed on / popped:<ul><li><p>load: called when the window is pushed to the screen when it's not loaded. This is a good moment to do the layout of the window.</p></li><li><p>appear: called when the window comes on the screen (again). E.g. when second-top-most window gets revealed (again) after popping the top-most window, but also when the window is pushed for the first time. This is a good moment to start timers related to the window, or reset the UI, etc.</p></li><li><p>disappear:called when the window leaves the screen, e.g. when another window is pushed, or this window is popped. Good moment to stop timers related to the window.</p></li><li><p>unload: called when the window is deinited, but could be used in the future to free resources bound to windows that are not on screen.</p></li></ul>\n</p><p>All these handlers use WindowHandler as their function signature. \n</p>"
    }, 
    "bluetooth_connection_service_peek": {
        "kind": "fn", 
        "name": "bluetooth_connection_service_peek", 
        "return_desc": "<p>true if connected, false otherwise </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [], 
        "description": "<p>Query the bluetooth connection service for the current connection status"
    }, 
    "fonts_unload_custom_font": {
        "kind": "fn", 
        "name": "fonts_unload_custom_font", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>When an application exits, the system automatically unloads all fonts that have been loaded. </p>", 
        "params": [
            {
                "type": "GFont", 
                "name": "font", 
                "description": "<p>The font to unload. </p>"
            }
        ], 
        "description": "<p>Unloads the specified custom font and frees the memory that is occupied by it."
    }, 
    "ACCEL_SAMPLING_50HZ": {
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_50HZ", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>50 HZ sampling rate </p>"
    }, 
    "window_set_click_config_provider_with_context": {
        "kind": "fn", 
        "name": "window_set_click_config_provider_with_context", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the click config provider </p>"
            }, 
            {
                "type": "ClickConfigProvider", 
                "name": "click_config_provider", 
                "description": "<p>The callback that will be called to configure the click recognizers with the window </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>Pointer to application specific data that will be passed to the click configuration provider callback. </p>"
            }
        ], 
        "description": "<p>Same as <code>window_set_click_config_provider()</code>, but will assign a custom context pointer (instead of the window pointer) that will be passed into the ClickHandler click event handlers. \n</p>"
    }, 
    "layer_mark_dirty": {
        "kind": "fn", 
        "name": "layer_mark_dirty", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": "<p>The layer to mark dirty </p>"
            }
        ], 
        "description": "<p>Marks the complete layer as \"dirty\", awaiting to be asked by the system to redraw itself. Typically, this function is called whenever state has changed that affects what the layer is displaying.<ul><li><p>The layer's .<code>update_proc</code> will not be called before this function returns, but will be called asynchronously, shortly.</p></li><li><p>Internally, a call to this function will schedule a re-render of the window that the layer belongs to. In effect, all layers in that window's layer hierarchy will be asked to redraw.</p></li><li><p>If an earlier re-render request is still pending, this function is a no-op. </li></ul>\n</p>"
    }, 
    "NUM_BUTTONS": {
        "kind": "enum", 
        "name": "NUM_BUTTONS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Total number of buttons. </p>"
    }, 
    "app_message_outbox_begin": {
        "kind": "fn", 
        "name": "app_message_outbox_begin", 
        "return_desc": "<p>A result code, including but not limited to <code>APP_MSG_OK</code>, <code>APP_MSG_INVALID_ARGS</code> or <code>APP_MSG_BUSY</code>.</p>", 
        "returns": "AppMessageResult", 
        "warning": "<p>After a successful call, one can add values to the dictionary using functions like <code>dict_write_data()</code> and friends.</p>", 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iterator", 
                "description": "<p>Location to write the DictionaryIterator pointer. This will be NULL on failure.</p>"
            }
        ], 
        "description": "<p>Begin writing to the Outbox's Dictionary buffer.</p><p>\n</p>"
    }, 
    "animation_is_scheduled": {
        "kind": "fn", 
        "name": "animation_is_scheduled", 
        "return_desc": "<p>True if the animation was scheduled, or false if it was not. </p>", 
        "returns": "bool", 
        "warning": "<p>An animation will be scheduled when it is running and not finished yet. An animation that has finished is automatically unscheduled. </p>", 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation for which to get its scheduled state. </p>"
            }
        ], 
        "description": "<p>\n</p>"
    }, 
    "scroll_layer_set_callbacks": {
        "kind": "fn", 
        "name": "scroll_layer_set_callbacks", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the context is NULL, a pointer to <code>scroll_layer</code> is used as context parameter instead when calling callbacks. </p>", 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to assign new callbacks. </p>"
            }, 
            {
                "type": "ScrollLayerCallbacks", 
                "name": "callbacks", 
                "description": "<p>The new callbacks. </p>"
            }
        ], 
        "description": "<p>Sets the callbacks that the scroll layer exposes. The context as set by <code>scroll_layer_set_context()</code> is passed into each of the callbacks. See ScrollLayerCallbacks for the different callbacks."
    }, 
    "scroll_layer_scroll_down_click_handler": {
        "kind": "fn", 
        "name": "scroll_layer_scroll_down_click_handler", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This handler is exposed, in case one wants to implement an alternative handler for the DOWN button, as a way to invoke the default behavior. </p>", 
        "params": [
            {
                "type": "ClickRecognizerRef", 
                "name": "recognizer", 
                "description": "<p>The click recognizer for which the handler is called </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>A void pointer to the ScrollLayer that is the context of the click event </p>"
            }
        ], 
        "description": "<p>The click handlers for the DOWN button that the scroll layer will install as part of <code>scroll_layer_set_click_config_onto_window()</code>."
    }, 
    "number_window_set_label": {
        "kind": "fn", 
        "name": "number_window_set_label", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "NumberWindow *", 
                "name": "numberwindow", 
                "description": "<p>Pointer to the NumberWindow for which to set the label text </p>"
            }, 
            {
                "type": "const char *", 
                "name": "label", 
                "description": "<p>The new label text. Must be long-lived and cannot be stack-allocated. </p>"
            }
        ], 
        "description": "<p>Sets the text of the title or prompt label."
    }, 
    "window_get_fullscreen": {
        "kind": "fn", 
        "name": "window_get_fullscreen", 
        "return_desc": "<p>True if the window is marked as fullscreen, false if it is not marked as fullscreen. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "const Window *", 
                "name": "window", 
                "description": "<p>The window for which to get its full-screen property </p>"
            }
        ], 
        "description": "<p>Gets whether the window is full-screen, consequently hiding the sytem status bar."
    }, 
    "graphics_text_layout_get_content_size": {
        "kind": "fn", 
        "name": "graphics_text_layout_get_content_size", 
        "return_desc": "<p>The maximum size occupied by the text </p>", 
        "returns": "GSize", 
        "warning": null, 
        "params": [
            {
                "type": "const char *", 
                "name": "text", 
                "description": "<p>The zero terminated UTF-8 string for which to calculate the size </p>"
            }, 
            {
                "type": "GFont", 
                "name": "font", 
                "description": "<p>The font in which the text should be set while calculating the size </p>"
            }, 
            {
                "type": "GRect", 
                "name": "box", 
                "description": "<p>The bounding box in which the text should be constrained </p>"
            }, 
            {
                "type": "GTextOverflowMode", 
                "name": "overflow_mode", 
                "description": "<p>The overflow behavior, in case the text is larger than what fits inside the box. </p>"
            }, 
            {
                "type": "GTextAlignment", 
                "name": "alignment", 
                "description": "<p>The horizontal alignment of the text </p>"
            }
        ], 
        "description": "<p>Obtain the maximum size that a text with given font, overflow mode and alignment occupies within a given rectangular constraint."
    }, 
    "Window": {
        "kind": "typedef", 
        "name": "Window", 
        "return_desc": null, 
        "returns": "struct Window", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "Animation": {
        "kind": "typedef", 
        "name": "Animation", 
        "return_desc": null, 
        "returns": "Animation", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "inverter_layer_get_layer": {
        "kind": "fn", 
        "name": "inverter_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the inverter layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "InverterLayer *", 
                "name": "inverter_layer", 
                "description": "<p>Pointer to the InverterLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the inverter layer, which is the parent for the sub- layers used for its implementation."
    }, 
    "GTextOverflowModeWordWrap": {
        "kind": "enum", 
        "name": "GTextOverflowModeWordWrap", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>On overflow, wrap words to a new line below the current one. Once vertical space is consumed, the last line may be clipped. </p>"
    }, 
    "dict_write_uint16": {
        "kind": "fn", 
        "name": "dict_write_uint16", 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": null
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": null
            }, 
            {
                "type": "const uint16_t", 
                "name": "value", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "scroll_layer_set_click_config_onto_window": {
        "kind": "fn", 
        "name": "scroll_layer_set_click_config_onto_window", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer that needs to receive click events. </p>"
            }, 
            {
                "type": "struct Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the click configuration. </p>"
            }
        ], 
        "description": "<p>Convenience function to set the ClickConfigProvider callback on the given window to scroll layer's internal click config provider. This internal click configuration provider, will set up the default UP & DOWN scrolling behavior. This function calls <code>window_set_click_config_provider_with_context</code> to accomplish this.</p><p>If you application has set a .<code>click_config_provider</code> callback using <code>scroll_layer_set_callbacks()</code>, this will be called by the internal click config provider, after configuring the UP & DOWN buttons. This allows your application to configure the SELECT button behavior and optionally override the UP & DOWN button behavior. The callback context for the SELECT click recognizer is automatically set to the scroll layer's context (see <code>scroll_layer_set_context()</code> ). This context is passed into ClickHandler callbacks. For the UP and DOWN buttons, the scroll layer itself is passed in by default as the callback context in order to deal with those buttons presses to scroll up and down automatically. \n</p>"
    }, 
    "ACCEL_SAMPLING_10HZ": {
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_10HZ", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>10 HZ sampling rate </p>"
    }, 
    "MenuRowAlignNone": {
        "kind": "enum", 
        "name": "MenuRowAlignNone", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Don't align or update the scroll offset of the MenuLayer. </p>"
    }, 
    "persist_read_string": {
        "kind": "fn", 
        "name": "persist_read_string", 
        "return_desc": "<p>The number of bytes written into the buffer or <code>E_DOES_NOT_EXIST</code> if there is no field matching the given key. </p>", 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to read from. </p>"
            }, 
            {
                "type": "char *", 
                "name": "buffer", 
                "description": "<p>The pointer to a buffer to be written to. </p>"
            }, 
            {
                "type": "const size_t", 
                "name": "buffer_size", 
                "description": "<p>The maximum size of the given buffer. This includes the null character. </p>"
            }
        ], 
        "description": "<p>Reads a string for a given key from persistent storage into a given buffer. The string will be null terminated. If the value has not yet been set, the given buffer is left unchanged."
    }, 
    "graphics_draw_circle": {
        "kind": "fn", 
        "name": "graphics_draw_circle", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "p", 
                "description": "<p>The center point of the circle </p>"
            }, 
            {
                "type": "uint16_t", 
                "name": "radius", 
                "description": "<p>The radius in pixels </p>"
            }
        ], 
        "description": "<p>Draws the outline of a circle in the current stroke color"
    }, 
    "number_window_get_value": {
        "kind": "fn", 
        "name": "number_window_get_value", 
        "return_desc": "<p>The current value </p>", 
        "returns": "int32_t", 
        "warning": null, 
        "params": [
            {
                "type": "const NumberWindow *", 
                "name": "numberwindow", 
                "description": "<p>Pointer to the NumberWindow for which to get the current value </p>"
            }
        ], 
        "description": "<p>Gets the current value"
    }, 
    "__attribute__": {
        "kind": "fn", 
        "name": "__attribute__", 
        "return_desc": null, 
        "returns": "struct", 
        "warning": "<p>The structure is variable length! The length depends on the value data that the tuple contains.</p>", 
        "params": [], 
        "description": "<p>A single accelerometer sample for all three axes including timestamp and vibration rumble status.</p><p>Data structure for one serialized key/value tuple <p>Note that this structure does NOT contain any pixel data; it only has a pointer to a buffer containing the pixels (the addr field). The metadata describes how long each row of pixels is in the buffer (the stride). Each row must be a multiple of 32 pixels (4 bytes). Using the bounds field, the area that is actually relevant can be specified.</p><p>For example, when the image is 29 by 5 pixels (width by height) and the first bit of image data is the pixel at (0, 0), then the bounds.size would be GSize(29, 5) and bounds.origin would be GPoint(0, 0). \n In the illustration each pixel is a representated as a square. The white squares are the bits that are used, the gray squares are the padding bits, because each row of image data has to be a multiple of 4 bytes (32 bits). The numbers in the column in the left are the offsets (in bytes) from the *addr field of the GBitmap.</p><p>Each pixel in a bitmap is represented by 1 bit. If a bit is set (1 or true), it will result in a white pixel, and vice versa, if a bit is cleared (0 or false), it will result in a black pixel. \n \n</p>"
    }, 
    "app_timer_register": {
        "kind": "fn", 
        "name": "app_timer_register", 
        "return_desc": null, 
        "returns": "AppTimer *", 
        "warning": null, 
        "params": [
            {
                "type": "uint32_t", 
                "name": "timeout_ms", 
                "description": "<p>The expiry time in milliseconds from the current time </p>"
            }, 
            {
                "type": "AppTimerCallback", 
                "name": "callback", 
                "description": "<p>The callback that gets called at expiry time </p>"
            }, 
            {
                "type": "void *", 
                "name": "callback_data", 
                "description": "<p>The data that will be passed to callback </p>"
            }
        ], 
        "description": "<p>Registers a timer that ends up in callback being called some specified time in the future."
    }, 
    "window_set_status_bar_icon": {
        "kind": "fn", 
        "name": "window_set_status_bar_icon", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This needs to be called before pushing a window to the window stack. </p>", 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the status bar icon </p>"
            }, 
            {
                "type": "const GBitmap *", 
                "name": "icon", 
                "description": "<p>The new status bar icon </p>"
            }
        ], 
        "description": "<p>Assigns an icon (max. 16x16 pixels) that can be displayed in the system status bar. When no icon is assigned, the icon of the previous window on the window stack is used."
    }, 
    "gbitmap_destroy": {
        "kind": "fn", 
        "name": "gbitmap_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GBitmap *", 
                "name": "bitmap", 
                "description": null
            }
        ], 
        "description": "<p>Destroy a GBitmap; free the GBitmap's data if it is dynamically allocated. This must be called for every bitmap that's been created with <code>gbitmap_create_</code>* </p>"
    }, 
    "APP_MSG_CLOSED": {
        "kind": "enum", 
        "name": "APP_MSG_CLOSED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>App message was closed. </p>"
    }, 
    "AccelTapHandler": {
        "kind": "typedef", 
        "name": "AccelTapHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback type for accelerometer tap events"
    }, 
    "grect_equal": {
        "kind": "fn", 
        "name": "grect_equal", 
        "return_desc": "<p>true if both rectangles are equal, false if not. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "rect_a", 
                "description": "<p>Pointer to the first rectangle </p>"
            }, 
            {
                "type": "GRect", 
                "name": "rect_b", 
                "description": "<p>Pointer to the second rectangle </p>"
            }
        ], 
        "description": "<p>Tests whether 2 rectangles are equal."
    }, 
    "app_log": {
        "kind": "fn", 
        "name": "app_log", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>We do not have floating point number support in formatting strings </p>", 
        "params": [
            {
                "type": "uint8_t", 
                "name": "log_level", 
                "description": "<p></p>"
            }, 
            {
                "type": "const char *", 
                "name": "src_filename", 
                "description": "<p>The source file where the log originates from </p>"
            }, 
            {
                "type": "int", 
                "name": "src_line_number", 
                "description": "<p>The line number in the source file where the log originates from </p>"
            }, 
            {
                "type": "const char *", 
                "name": "fmt", 
                "description": "<p>A C formatting string </p>"
            }
        ], 
        "description": "<p>Log an app message. Refer the snprintf manpage for details about the C formatting string format."
    }, 
    "data_logging_log": {
        "kind": "fn", 
        "name": "data_logging_log", 
        "return_desc": "<p><code>DATA_LOGGING_SUCCESS</code> on success <code>DATA_LOGGING_NOT_FOUND</code> if the logging session is invalid <code>DATA_LOGGING_CLOSED</code> if the sesion is not active <code>DATA_LOGGING_BUSY</code> if the sesion is not available for writing <code>DATA_LOGGING_INVALID_PARAMS</code> if <code>num_items</code> is 0 or data is NULL </p>", 
        "returns": "DataLoggingResult", 
        "warning": null, 
        "params": [
            {
                "type": "DataLoggingSessionRef", 
                "name": "logging_session", 
                "description": "<p>a reference to the data logging session you want to add the data to </p>"
            }, 
            {
                "type": "const void *", 
                "name": "data", 
                "description": "<p>a pointer to the data buffer that contains multiple items </p>"
            }, 
            {
                "type": "uint32_t", 
                "name": "num_items", 
                "description": "<p>the number of items to log. This means data must be at least (<code>num_items</code> * <code>item_length</code>) long in bytes </p>"
            }
        ], 
        "description": "<p>Add data to the data logging session. If a phone is available, the data is sent directly to the phone. Otherwise, it is saved to the watch storage until the watch is connected to a phone.</p><p>"
    }, 
    "NUM_ACTION_BAR_ITEMS": {
        "kind": "def", 
        "name": "NUM_ACTION_BAR_ITEMS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The maximum number of action bar items. </p>"
    }, 
    "GCornersTop": {
        "kind": "enum", 
        "name": "GCornersTop", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Top corners. </p>"
    }, 
    "dict_calc_buffer_size_from_tuplets": {
        "kind": "fn", 
        "name": "dict_calc_buffer_size_from_tuplets", 
        "return_desc": "<p>The total number of bytes of storage needed. </p>", 
        "returns": "uint32_t", 
        "warning": "<p>See <code>dict_calc_buffer_size()</code> for the formula for the calculation. </p>", 
        "params": [
            {
                "type": "Tuplet", 
                "name": "tuplets", 
                "description": "<p>An array of Tuplets that need to be stored in the dictionary. </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "tuplets_count", 
                "description": "<p>The total number of Tuplets that follow. </p>"
            }
        ], 
        "description": "<p>Calculates the number of bytes that a dictionary will occupy, given one or more Tuplets that need to be stored in the dictionary. \n</p>"
    }, 
    "text_layer_set_text_color": {
        "kind": "fn", 
        "name": "text_layer_set_text_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the text color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": "<p>The new GColor to set the text color to </p>"
            }
        ], 
        "description": "<p>Sets the color of text that will be drawn \n</p>"
    }, 
    "gpath_draw_filled": {
        "kind": "fn", 
        "name": "gpath_draw_filled", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The graphics context to draw into </p>"
            }, 
            {
                "type": "GPath", 
                "name": "path", 
                "description": "<p>The path to fill </p>"
            }
        ], 
        "description": "<p>Draws the fill of a path into a graphics context, using the current fill color, relative to the drawing area as set up by the layering system. \n</p>"
    }, 
    "Int16Setter": {
        "kind": "typedef", 
        "name": "Int16Setter", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of a setter function to set a property of type <code>int16_t</code> onto the subject. \n</p>"
    }, 
    "MenuRowAlignBottom": {
        "kind": "enum", 
        "name": "MenuRowAlignBottom", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Scroll the contents of the MenuLayer in such way that the selected row is at the bottom of the visible area. </p>"
    }, 
    "DATA_LOGGING_UINT": {
        "kind": "enum", 
        "name": "DATA_LOGGING_UINT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unsigned integer. This may be a 1, 2, or 4 byte integer depending on the <code>item_length</code> parameter. </p>"
    }, 
    "menu_cell_basic_header_draw": {
        "kind": "fn", 
        "name": "menu_cell_basic_header_draw", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context </p>"
            }, 
            {
                "type": "const Layer *", 
                "name": "cell_layer", 
                "description": "<p>The layer of the cell to draw </p>"
            }, 
            {
                "type": "const char *", 
                "name": "title", 
                "description": "<p>If non-null, draws the title in small text (14 points, bold Raster Gothic system font). </p>"
            }
        ], 
        "description": "<p>Section header drawing function to draw a basic section header cell layout with the title of the section. Call this function inside the .<code>draw_header</code> callback implementation, see MenuLayerCallbacks."
    }, 
    "MenuLayerSelectCallback": {
        "kind": "typedef", 
        "name": "MenuLayerSelectCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to handle the event that a user hits the SELECT button. \n</p>"
    }, 
    "layer_get_window": {
        "kind": "fn", 
        "name": "layer_get_window", 
        "return_desc": "<p>The window that this layer is currently attached to, or NULL if it has not been added to a window's layer hierarchy. </p>", 
        "returns": "struct Window *", 
        "warning": null, 
        "params": [
            {
                "type": "const Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to get the window </p>"
            }
        ], 
        "description": "<p>Gets the window that the layer is currently attached to. \n</p>"
    }, 
    "ScrollLayerCallbacks": {
        "kind": "typedef", 
        "name": "ScrollLayerCallbacks", 
        "return_desc": null, 
        "returns": "ScrollLayerCallbacks", 
        "warning": "<p>The context parameter can be set using <code>scroll_layer_set_context()</code> and gets passed in as context with all of these callbacks. </p>", 
        "params": [], 
        "description": "<p>All the callbacks that the ScrollLayer exposes for use by applications."
    }, 
    "window_get_click_config_provider": {
        "kind": "fn", 
        "name": "window_get_click_config_provider", 
        "return_desc": null, 
        "returns": "ClickConfigProvider", 
        "warning": null, 
        "params": [
            {
                "type": "const Window *", 
                "name": "window", 
                "description": "<p>The window for which to get the click config provider </p>"
            }
        ], 
        "description": "<p>Gets the current click configuration provider of the window."
    }, 
    "vibes_enqueue_custom_pattern": {
        "kind": "fn", 
        "name": "vibes_enqueue_custom_pattern", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "VibePattern", 
                "name": "pattern", 
                "description": "<p>An arbitrary vibration pattern </p>"
            }
        ], 
        "description": "<p>Makes the watch emit a \u2018custom\u2019 vibration pattern. \n</p>"
    }, 
    "layer_remove_child_layers": {
        "kind": "fn", 
        "name": "layer_remove_child_layers", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "parent", 
                "description": "<p>The layer from which to remove all child layers </p>"
            }
        ], 
        "description": "<p>Removes child layers from given layer If removed successfully, the child's parent layer will be marked dirty automatically."
    }, 
    "MENU_CELL_BASIC_HEADER_HEIGHT": {
        "kind": "def", 
        "name": "MENU_CELL_BASIC_HEADER_HEIGHT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Default section header height in pixels. </p>"
    }, 
    "action_bar_layer_clear_icon": {
        "kind": "fn", 
        "name": "action_bar_layer_clear_icon", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar for which to clear an icon </p>"
            }, 
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The identifier of the button for which to clear the icon </p>"
            }
        ], 
        "description": "<p>Convenience function to clear out an existing icon. All it does is call <code>action_bar_layer_set_icon</code>(<code>action_bar</code>, <code>button_id</code>, NULL) \n</p>"
    }, 
    "text_layer_destroy": {
        "kind": "fn", 
        "name": "text_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a TextLayer previously created by <code>text_layer_create</code>. </p>"
    }, 
    "APP_LOG": {
        "kind": "def", 
        "name": "APP_LOG", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "text_layer_set_text": {
        "kind": "fn", 
        "name": "text_layer_set_text", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>The string is not copied, so its buffer most likely cannot be stack allocated, but is recommended to be a buffer that is long-lived, at least as long as the TextLayer is part of a visible Layer hierarchy. </p>", 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the text </p>"
            }, 
            {
                "type": "const char *", 
                "name": "text", 
                "description": "<p>The new text to set onto the TextLayer. This must be a null-terminated and valid UTF-8 string! </p>"
            }
        ], 
        "description": "<p>Sets the pointer to the string where the TextLayer is supposed to find the text at a later point in time, when it needs to draw itself. \n</p>"
    }, 
    "ANIMATION_NORMALIZED_MAX": {
        "kind": "def", 
        "name": "ANIMATION_NORMALIZED_MAX", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The normalized time at the end of the animation. </p>"
    }, 
    "graphics_context_set_compositing_mode": {
        "kind": "fn", 
        "name": "graphics_context_set_compositing_mode", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>At the moment, this only affects the bitmaps drawing operations  <code>graphics_draw_bitmap_in_rect()</code> and anything that uses that , but it currently does not affect the filling or stroking operations. </p>", 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The graphics context onto which to set the compositing mode </p>"
            }, 
            {
                "type": "GCompOp", 
                "name": "mode", 
                "description": "<p>The new compositing mode </p>"
            }
        ], 
        "description": "<p>Sets the current bitmap compositing mode of the graphics context."
    }, 
    "GAlignBottom": {
        "kind": "enum", 
        "name": "GAlignBottom", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the bottom edges overlap and centered horizontally. </p>"
    }, 
    "ACTION_BAR_WIDTH": {
        "kind": "def", 
        "name": "ACTION_BAR_WIDTH", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The width of the action bar in pixels. </p>"
    }, 
    "TextLayout": {
        "kind": "typedef", 
        "name": "TextLayout", 
        "return_desc": null, 
        "returns": "struct TextLayout", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "layer_get_frame": {
        "kind": "fn", 
        "name": "layer_get_frame", 
        "return_desc": "<p>The frame of the layer </p>", 
        "returns": "GRect", 
        "warning": null, 
        "params": [
            {
                "type": "const Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to get the frame </p>"
            }
        ], 
        "description": "<p>Gets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. If the frame has changed, <code>layer_mark_dirty()</code> will be called automatically. \n</p>"
    }, 
    "app_event_loop": {
        "kind": "fn", 
        "name": "app_event_loop", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>The event loop for apps, to be used in app's main(). Will block until the app is ready to exit. \n</p>"
    }, 
    "rot_bitmap_layer_destroy": {
        "kind": "fn", 
        "name": "rot_bitmap_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "RotBitmapLayer *", 
                "name": "bitmap", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "S_SUCCESS": {
        "kind": "enum", 
        "name": "S_SUCCESS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Operation completed successfully. </p>"
    }, 
    "dict_serialize_tuplets_to_buffer_with_iter": {
        "kind": "fn", 
        "name": "dict_serialize_tuplets_to_buffer_with_iter", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "Tuplet", 
                "name": "tuplets", 
                "description": "<p>The array of tuplets </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "tuplets_count", 
                "description": "<p>The number of tuplets in the array </p>"
            }, 
            {
                "type": "uint8_t *", 
                "name": "buffer", 
                "description": "<p>The buffer in which to write the serialized dictionary </p>"
            }, 
            {
                "type": "uint32_t *", 
                "name": "size_in_out", 
                "description": "<p>The number of bytes written </p>"
            }
        ], 
        "description": "<p>Serializes an array of Tuplets into a dictionary with a given buffer and size."
    }, 
    "battery_state_service_subscribe": {
        "kind": "fn", 
        "name": "battery_state_service_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BatteryStateHandler", 
                "name": "handler", 
                "description": "<p>A callback to be executed on battery state change event </p>"
            }
        ], 
        "description": "<p>Subscribe to the battery state event service. Once subscribed, the handler gets called on every battery state change"
    }, 
    "APP_MSG_NOT_CONNECTED": {
        "kind": "enum", 
        "name": "APP_MSG_NOT_CONNECTED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The other end was not connected. </p>"
    }, 
    "layer_set_frame": {
        "kind": "fn", 
        "name": "layer_set_frame", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to set the frame </p>"
            }, 
            {
                "type": "GRect", 
                "name": "frame", 
                "description": "<p>The new frame </p>"
            }
        ], 
        "description": "<p>Sets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. The size of the layer's bounds will be extended automatically, so that the bounds cover the new frame. \n</p>"
    }, 
    "number_window_set_max": {
        "kind": "fn", 
        "name": "number_window_set_max", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "NumberWindow *", 
                "name": "numberwindow", 
                "description": "<p>Pointer to the NumberWindow for which to set the maximum value </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "max", 
                "description": "<p>The maximum value </p>"
            }
        ], 
        "description": "<p>Sets the maximum value this field can hold"
    }, 
    "app_message_inbox_size_maximum": {
        "kind": "fn", 
        "name": "app_message_inbox_size_maximum", 
        "return_desc": "<p>The inbox size maximum on this firmware.</p>", 
        "returns": "uint32_t", 
        "warning": null, 
        "params": [], 
        "description": "<p>Programatically determine the inbox size maximum in the current configuration.</p><p>\n</p>"
    }, 
    "ANIMATION_DURATION_INFINITE": {
        "kind": "def", 
        "name": "ANIMATION_DURATION_INFINITE", 
        "return_desc": null, 
        "returns": "", 
        "warning": "<p>Note that <code>time_normalized</code> parameter that is passed into the .update implementation is meaningless in when an infinite duration is used. </p>", 
        "params": [], 
        "description": "<p>Constant to indicate \"infinite\" duration. This can be used with <code>animation_set_duration()</code> to indicate that the animation should run indefinitely. This is useful when implementing for example a frame-by-frame simulation that does not have a clear ending (e.g. a game)."
    }, 
    "window_raw_click_subscribe": {
        "kind": "fn", 
        "name": "window_raw_click_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p><p>The back button cannot be overridden with a raw click. </p>", 
        "params": [
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The button events to subscribe to. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "down_handler", 
                "description": "<p>The ClickHandler to fire as soon as the button has been pressed. This may be NULL to have no down handler. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "up_handler", 
                "description": "<p>The ClickHandler to fire on the release of the button. This may be NULL to have no up handler. </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>If this context is not NULL, it will override the general context. </p>"
            }
        ], 
        "description": "<p>Subscribe to raw click events."
    }, 
    "PBL_APP_INFO": {
        "kind": "def", 
        "name": "PBL_APP_INFO", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "GCornerTopRight": {
        "kind": "enum", 
        "name": "GCornerTopRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Top-Right corner. </p>"
    }, 
    "window_create": {
        "kind": "fn", 
        "name": "window_create", 
        "return_desc": "<p>A pointer to the window. NULL if the window could not be created </p>", 
        "returns": "Window *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Creates a new Window on the heap and initalizes it with the default values.</p><p><ul><li><p>Background color : GColorWhite</p></li><li><p>Root layer's <code>update_proc</code> : function that fills the window's background using <code>background_color</code>.</p></li><li><p>Full screen : no</p></li><li><p><code>click_config_provider</code> : NULL</p></li><li><p><code>window_handlers</code> : all NULL</p></li><li><p><code>status_bar_icon</code> : NULL (none) </li></ul>\n</p>"
    }, 
    "bitmap_layer_destroy": {
        "kind": "fn", 
        "name": "bitmap_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a window previously created by <code>bitmap_layer_create</code>. </p>"
    }, 
    "GAlignRight": {
        "kind": "enum", 
        "name": "GAlignRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the right edges overlap and centered vertically. </p>"
    }, 
    "AnimationCurveEaseIn": {
        "kind": "enum", 
        "name": "AnimationCurveEaseIn", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Bicubic ease-in: accelerate from zero velocity. </p>"
    }, 
    "AppMessageOutboxFailed": {
        "kind": "typedef", 
        "name": "AppMessageOutboxFailed", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Called after an outbound message has not been sent successfully.</p><p><code>app_message_outbox_begin()</code> from this handler to prepare a new message. This will invalidate the previous dictionary iterator; do not use it after calling <code>app_message_outbox_begin()</code>. </p>"
    }, 
    "cos_lookup": {
        "kind": "fn", 
        "name": "cos_lookup", 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null, 
        "params": [
            {
                "type": "int32_t", 
                "name": "angle", 
                "description": "<p>The angle for which to compute the cosine. The angle value is scaled linearly, such that a value of 0x10000 corresponds to 360 degrees or 2 PI radians. </p>"
            }
        ], 
        "description": "<p>Look-up the cosine of the given angle from a pre-computed table. This is equivalent to calling <code>sin_lookup</code>(angle + <code>MAX_ANGLE</code> / 4)."
    }, 
    "GAlignTopRight": {
        "kind": "enum", 
        "name": "GAlignTopRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the top edges overlap and left edges overlap. </p>"
    }, 
    "dict_read_begin_from_buffer": {
        "kind": "fn", 
        "name": "dict_read_begin_from_buffer", 
        "return_desc": "<p>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </p>", 
        "returns": "Tuple *", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "const uint8_t *const", 
                "name": "buffer", 
                "description": "<p>The storage of the dictionary </p>"
            }, 
            {
                "type": "const uint16_t", 
                "name": "size", 
                "description": "<p>The storage size of the dictionary </p>"
            }
        ], 
        "description": "<p>Initializes the dictionary iterator with a given buffer and size, in preparation of reading key/value tuples."
    }, 
    "resource_load_byte_range": {
        "kind": "fn", 
        "name": "resource_load_byte_range", 
        "return_desc": "<p>The number of bytes actually copied </p>", 
        "returns": "size_t", 
        "warning": null, 
        "params": [
            {
                "type": "ResHandle", 
                "name": "h", 
                "description": "<p>The handle to the resource </p>"
            }, 
            {
                "type": "uint32_t", 
                "name": "start_offset", 
                "description": "<p>The offset in bytes at which to start reading from the resource </p>"
            }, 
            {
                "type": "uint8_t *", 
                "name": "buffer", 
                "description": null
            }, 
            {
                "type": "size_t", 
                "name": "num_bytes", 
                "description": "<p>The maximum number of bytes to copy </p>"
            }
        ], 
        "description": "<p>Copies a range of bytes from a resource with a given handle into a given buffer."
    }, 
    "GCornersAll": {
        "kind": "enum", 
        "name": "GCornersAll", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>All corners. </p>"
    }, 
    "DATA_LOGGING_INVALID_PARAMS": {
        "kind": "enum", 
        "name": "DATA_LOGGING_INVALID_PARAMS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>An invalid parameter was passed to one of the functions. </p>"
    }, 
    "accel_data_service_subscribe": {
        "kind": "fn", 
        "name": "accel_data_service_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Cannot use <code>accel_service_peek()</code> when subscribed to accelerometer data events. </p>", 
        "params": [
            {
                "type": "uint32_t", 
                "name": "samples_per_update", 
                "description": "<p>the number of samples to buffer, between 0 and 25. </p>"
            }, 
            {
                "type": "AccelDataHandler", 
                "name": "handler", 
                "description": "<p>A callback to be executed on accelerometer data events </p>"
            }
        ], 
        "description": "<p>Subscribe to the accelerometer data event service. Once subscribed, the handler gets called every time there are new accelerometer samples available."
    }, 
    "app_message_deregister_callbacks": {
        "kind": "fn", 
        "name": "app_message_deregister_callbacks", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Deregisters all callbacks and their context. </p>"
    }, 
    "ScrollLayerCallback": {
        "kind": "typedef", 
        "name": "ScrollLayerCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the .<code>content_offset_changed_handler</code> callback. </p>"
    }, 
    "RotBitmapLayer": {
        "kind": "typedef", 
        "name": "RotBitmapLayer", 
        "return_desc": null, 
        "returns": "struct RotBitmapLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "property_animation_update_gpoint": {
        "kind": "fn", 
        "name": "property_animation_update_gpoint", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This function is not supposed to be called \"manually\", but will be called automatically when the animation is being run. </p>", 
        "params": [
            {
                "type": "PropertyAnimation", 
                "name": "property_animation", 
                "description": "<p>The property animation for which the update is requested. </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "time_normalized", 
                "description": "<p>The current normalized time. See AnimationUpdateImplementation </p>"
            }
        ], 
        "description": "<p>Default update callback for a property animations to update a property of type GPoint. Assign this function to the .base.update callback field of your PropertyAnimationImplementation, in combination with a .getter and .setter accessors of types GPointGetter and GPointSetter. The implementation of this function will calculate the next point of the animation and call the setter to set the new point upon the subject."
    }, 
    "menu_layer_get_scroll_layer": {
        "kind": "fn", 
        "name": "menu_layer_get_scroll_layer", 
        "return_desc": "<p>The ScrollLayer of the menu layer. </p>", 
        "returns": "ScrollLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "const MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>Pointer to the MenuLayer for which to get the ScrollLayer </p>"
            }
        ], 
        "description": "<p>Gets the ScrollLayer of the menu layer, which is the layer responsible for the scrolling of the menu layer."
    }, 
    "app_sync_get": {
        "kind": "fn", 
        "name": "app_sync_get", 
        "return_desc": "<p>Pointer to a found Tuple, or NULL if there was no Tuple with the specified key. </p>", 
        "returns": "const Tuple *", 
        "warning": null, 
        "params": [
            {
                "type": "AppSync", 
                "name": "s", 
                "description": "<p>The AppSync context </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key for which to find a Tuple </p>"
            }
        ], 
        "description": "<p>Finds and gets a tuple in the \"current\" dictionary."
    }, 
    "window_multi_click_subscribe": {
        "kind": "fn", 
        "name": "window_multi_click_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p>", 
        "params": [
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The button events to subscribe to. </p>"
            }, 
            {
                "type": "uint8_t", 
                "name": "min_clicks", 
                "description": null
            }, 
            {
                "type": "uint8_t", 
                "name": "max_clicks", 
                "description": null
            }, 
            {
                "type": "uint16_t", 
                "name": "timeout", 
                "description": "<p>The delay after which a sequence of clicks is considered finished, and the click counter is reset. A value of 0 means to use the system default 300ms. </p>"
            }, 
            {
                "type": "bool", 
                "name": "last_click_only", 
                "description": "<p>Defaults to false. When true, only the handler for the last multi-click is called. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "handler", 
                "description": "<p>The ClickHandler to fire on this event. Fired for multi-clicks, as \"filtered\" by the <code>last_click_only</code>, min, and max parameters. </p>"
            }
        ], 
        "description": "<p>Subscribe to multi click events."
    }, 
    "data_logging_create": {
        "kind": "fn", 
        "name": "data_logging_create", 
        "return_desc": "<p>An opaque reference to the data logging session </p>", 
        "returns": "DataLoggingSessionRef", 
        "warning": null, 
        "params": [
            {
                "type": "uint32_t", 
                "name": "tag", 
                "description": "<p>A tag associated with the logging session. </p>"
            }, 
            {
                "type": "DataLoggingItemType", 
                "name": "item_type", 
                "description": "<p>The type of data stored in this logging session </p>"
            }, 
            {
                "type": "uint16_t", 
                "name": "item_length", 
                "description": "<p>The size of a single data item in bytes </p>"
            }, 
            {
                "type": "bool", 
                "name": "resume", 
                "description": "<p>True if we want to look for a logging session of the same tag and resume logging to it. If this is false and a session with the specified tag exists, that session will be closed and a new session will be opened. </p>"
            }
        ], 
        "description": "<p>Create a new data logging session.</p><p>"
    }, 
    "TickHandler": {
        "kind": "typedef", 
        "name": "TickHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback type for tick timer events"
    }, 
    "tick_timer_service_unsubscribe": {
        "kind": "fn", 
        "name": "tick_timer_service_unsubscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unsubscribe from the tick timer event service. Once unsubscribed, the previously registered handler will no longer be called. </p>"
    }, 
    "scroll_layer_get_layer": {
        "kind": "fn", 
        "name": "scroll_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the scroll layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "const ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>Pointer to the ScrollLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the scroll layer, which is the parent for the sub- layers used for its implementation."
    }, 
    "DICT_OK": {
        "kind": "enum", 
        "name": "DICT_OK", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The operation returned successfully. </p>"
    }, 
    "resource_size": {
        "kind": "fn", 
        "name": "resource_size", 
        "return_desc": "<p>The size of the resource in bytes </p>", 
        "returns": "size_t", 
        "warning": null, 
        "params": [
            {
                "type": "ResHandle", 
                "name": "h", 
                "description": "<p>The handle to the resource </p>"
            }
        ], 
        "description": "<p>Gets the size of the resource given a resource handle."
    }, 
    "dict_calc_buffer_size": {
        "kind": "fn", 
        "name": "dict_calc_buffer_size", 
        "return_desc": "<p>The total number of bytes of storage needed. </p>", 
        "returns": "uint32_t", 
        "warning": "<p>The formula to calculate the size of a Dictionary in bytes is: 1 + (n * 7) + D1 + ... + Dn Where n is the number of Tuples in the Dictionary and Dx are the sizes of the values in the Tuples. The size of the Dictionary header is 1 byte. The size of the header for each Tuple is 7 bytes. </p>", 
        "params": [
            {
                "type": "const uint8_t", 
                "name": "tuple_count", 
                "description": "<p>The total number of key/value pairs in the dictionary. </p>"
            }
        ], 
        "description": "<p>Calculates the number of bytes that a dictionary will occupy, given one or more value lengths that need to be stored in the dictionary."
    }, 
    "window_long_click_subscribe": {
        "kind": "fn", 
        "name": "window_long_click_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p><p>The back button cannot be overridden with a long click. </p>", 
        "params": [
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The button events to subscribe to. </p>"
            }, 
            {
                "type": "uint16_t", 
                "name": "delay_ms", 
                "description": "<p>Milliseconds after which \"handler\" is fired. A value of 0 means to use the system default 500ms. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "down_handler", 
                "description": "<p>The ClickHandler to fire as soon as the button has been held for <code>delay_ms</code>. This may be NULL to have no down handler. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "up_handler", 
                "description": "<p>The ClickHandler to fire on the release of a long click. This may be NULL to have no up handler. </p>"
            }
        ], 
        "description": "<p>Subscribe to long click events."
    }, 
    "DICT_NOT_ENOUGH_STORAGE": {
        "kind": "enum", 
        "name": "DICT_NOT_ENOUGH_STORAGE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>There was not enough backing storage to complete the operation. </p>"
    }, 
    "PropertyAnimation": {
        "kind": "typedef", 
        "name": "PropertyAnimation", 
        "return_desc": null, 
        "returns": "PropertyAnimation", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "scroll_layer_get_shadow_hidden": {
        "kind": "fn", 
        "name": "scroll_layer_get_shadow_hidden", 
        "return_desc": "<p>True if the shadow is hidden, false if it is not hidden. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "const ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The scroll layer for which to get the visibility </p>"
            }
        ], 
        "description": "<p>Gets the visibility of the scroll layer shadow."
    }, 
    "GColor": {
        "kind": "typedef", 
        "name": "GColor", 
        "return_desc": null, 
        "returns": "GColor", 
        "warning": null, 
        "params": [], 
        "description": "<p>Color values. </p>"
    }, 
    "YEAR_UNIT": {
        "kind": "enum", 
        "name": "YEAR_UNIT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Flag to represent the \"years\" time unit. </p>"
    }, 
    "light_enable": {
        "kind": "fn", 
        "name": "light_enable", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "bool", 
                "name": "enable", 
                "description": "<p>Turn the backlight on if true, otherwise false to put it back into automatic control. </p>"
            }
        ], 
        "description": "<p>Turn the watch's backlight on or put it back into automatic control. Developers should take care when calling this function, keeping Pebble's backlight on for long periods of time will rapidly deplete the battery."
    }, 
    "GTextAlignmentRight": {
        "kind": "enum", 
        "name": "GTextAlignmentRight", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Aligns the text to the right of the drawing box. </p>"
    }, 
    "AnimationStoppedHandler": {
        "kind": "typedef", 
        "name": "AnimationStoppedHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>The function pointer type of the handler that will be called when the animation is stopped. \n</p>"
    }, 
    "layer_get_hidden": {
        "kind": "fn", 
        "name": "layer_get_hidden", 
        "return_desc": "<p>True if the layer is hidden, false if it is not hidden. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "const Layer *", 
                "name": "layer", 
                "description": "<p>The layer for which to get the visibility </p>"
            }
        ], 
        "description": "<p>Gets the visibility of the layer."
    }, 
    "AppMessageInboxDropped": {
        "kind": "typedef", 
        "name": "AppMessageInboxDropped", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Called after an incoming message is dropped.</p><p><code>app_message_outbox_begin()</code> from this handler to prepare a new message. This will invalidate the previous dictionary iterator; do not use it after calling <code>app_message_outbox_begin()</code>. </p>"
    }, 
    "APP_LOG_LEVEL_WARNING": {
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_WARNING", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Warning level log message. </p>"
    }, 
    "dict_write_cstring": {
        "kind": "fn", 
        "name": "dict_write_cstring", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>The string will be copied into the backing storage of the dictionary. </p><p>There is no checking for duplicate keys. </p>", 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key </p>"
            }, 
            {
                "type": "const char *const", 
                "name": "cstring", 
                "description": "<p>Pointer to the zero-terminated C string </p>"
            }
        ], 
        "description": "<p>Adds a key with a C string value pair to the dictionary."
    }, 
    "graphics_draw_text": {
        "kind": "fn", 
        "name": "graphics_draw_text", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "const char *", 
                "name": "text", 
                "description": "<p>The zero terminated UTF-8 string to draw </p>"
            }, 
            {
                "type": "GFont", 
                "name": "font", 
                "description": "<p>The font in which the text should be set </p>"
            }, 
            {
                "type": "GRect", 
                "name": "box", 
                "description": "<p>The bounding box in which to draw the text. The first line of text will be drawn against the top of the box. </p>"
            }, 
            {
                "type": "GTextOverflowMode", 
                "name": "overflow_mode", 
                "description": "<p>The overflow behavior, in case the text is larger than what fits inside the box. </p>"
            }, 
            {
                "type": "GTextAlignment", 
                "name": "alignment", 
                "description": "<p>The horizontal alignment of the text </p>"
            }, 
            {
                "type": "GTextLayoutCacheRef", 
                "name": "layout", 
                "description": "<p>Optional layout cache data. Supply NULL to ignore the layout caching mechanism. </p>"
            }
        ], 
        "description": "<p>Draw text into the current graphics context, using the context's current text color. The text will be drawn inside a box with the specified dimensions and configuration, with clipping occuring automatically."
    }, 
    "action_bar_layer_get_layer": {
        "kind": "fn", 
        "name": "action_bar_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the action bar layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar_layer", 
                "description": "<p>Pointer to the ActionBarLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the action bar layer, which is the parent for the sub- layers used for its implementation."
    }, 
    "TupletBytes": {
        "kind": "def", 
        "name": "TupletBytes", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "TUPLE_INT": {
        "kind": "enum", 
        "name": "TUPLE_INT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The value is a signed integer. The tuple's .length field is used to determine the size of the integer (1, 2, or 4 bytes). </p>"
    }, 
    "gpath_move_to": {
        "kind": "fn", 
        "name": "gpath_move_to", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Setting a translation does not affect the points in the path directly. The translation is applied on-the-fly during drawing, either using <code>gpath_draw_filled()</code> or <code>gpath_draw_outline()</code>. </p>", 
        "params": [
            {
                "type": "GPath", 
                "name": "path", 
                "description": "<p>The path onto which to set the translation </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "point", 
                "description": "<p>The point which is used as the vector for the translation. </p>"
            }
        ], 
        "description": "<p>Sets the absolute offset of the path. The current translation will be replaced by the specified offset."
    }, 
    "GPoint": {
        "kind": "typedef", 
        "name": "GPoint", 
        "return_desc": null, 
        "returns": "GPoint", 
        "warning": "<p>Conventionally, the origin of Pebble's 2D coordinate system is in the upper, lefthand corner its x-axis extends to the right and its y-axis extends to the bottom of the screen. </p>", 
        "params": [], 
        "description": "<p>Represents a point in a 2-dimensional coordinate system."
    }, 
    "dict_serialize_tuplets_to_buffer": {
        "kind": "fn", 
        "name": "dict_serialize_tuplets_to_buffer", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "Tuplet", 
                "name": "tuplets", 
                "description": "<p>The array of tuplets </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "tuplets_count", 
                "description": "<p>The number of tuplets in the array </p>"
            }, 
            {
                "type": "uint8_t *", 
                "name": "buffer", 
                "description": "<p>The buffer in which to write the serialized dictionary </p>"
            }, 
            {
                "type": "uint32_t *", 
                "name": "size_in_out", 
                "description": "<p>The number of bytes written </p>"
            }
        ], 
        "description": "<p>Utility function that takes an array of Tuplets and serializes them into a dictionary with a given buffer and size."
    }, 
    "AnimationCurveEaseInOut": {
        "kind": "enum", 
        "name": "AnimationCurveEaseInOut", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Bicubic ease-in-out: accelerate from zero velocity, decelerate to zero velocity. </p>"
    }, 
    "DICT_INVALID_ARGS": {
        "kind": "enum", 
        "name": "DICT_INVALID_ARGS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>One or more arguments were invalid or uninitialized. </p>"
    }, 
    "property_animation_destroy": {
        "kind": "fn", 
        "name": "property_animation_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "PropertyAnimation", 
                "name": "property_animation", 
                "description": "<p>The property animation to be freed. </p>"
            }
        ], 
        "description": "<p>Free a dynamically allocated property animation"
    }, 
    "MINUTE_UNIT": {
        "kind": "enum", 
        "name": "MINUTE_UNIT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Flag to represent the \"minutes\" time unit. </p>"
    }, 
    "rot_bitmap_layer_create": {
        "kind": "fn", 
        "name": "rot_bitmap_layer_create", 
        "return_desc": "<p>A pointer to the RotBitmapLayer. NULL if the RotBitmapLayer could not be created </p>", 
        "returns": "RotBitmapLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "GBitmap *", 
                "name": "bitmap", 
                "description": null
            }
        ], 
        "description": "<p>"
    }, 
    "bitmap_layer_create": {
        "kind": "fn", 
        "name": "bitmap_layer_create", 
        "return_desc": "<p>A pointer to the BitmapLayer. NULL if the BitmapLayer could not be created </p>", 
        "returns": "BitmapLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": null
            }
        ], 
        "description": "<p>Creates a new bitmap layer on the heap and initalizes it the default values.</p><p><ul><li><p>Bitmap: NULL (none)</p></li><li><p>Background color: GColorClear</p></li><li><p>Compositing mode: GCompOpAssign</p></li><li><p>Clips: true </li></ul>\n</p>"
    }, 
    "action_bar_layer_set_icon": {
        "kind": "fn", 
        "name": "action_bar_layer_set_icon", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar for which to set the new icon </p>"
            }, 
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": "<p>The identifier of the button for which to set the icon </p>"
            }, 
            {
                "type": "const GBitmap *", 
                "name": "icon", 
                "description": "<p>Pointer to the GBitmap icon </p>"
            }
        ], 
        "description": "<p>Sets an action bar icon onto one of the 3 slots as identified by <code>button_id</code>. Only <code>BUTTON_ID_UP</code>, <code>BUTTON_ID_SELECT</code> and <code>BUTTON_ID_DOWN</code> can be used. Whenever an icon is set, the click configuration provider will be called, to give the application the opportunity to reconfigure the button interaction. \n</p>"
    }, 
    "dict_read_next": {
        "kind": "fn", 
        "name": "dict_read_next", 
        "return_desc": "<p>The next tuple in the dictionary, or NULL in case the end has been reached or if there was a parsing error. </p>", 
        "returns": "Tuple *", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }
        ], 
        "description": "<p>Progresses the iterator to the next key/value pair."
    }, 
    "MenuLayerDrawHeaderCallback": {
        "kind": "typedef", 
        "name": "MenuLayerDrawHeaderCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>The <code>cell_layer</code> argument is provided to make it easy to re-use an .<code>update_proc</code> implementation in this callback. Only the bounds and frame of the <code>cell_layer</code> are actually valid and other properties should be ignored. </p>", 
        "params": [], 
        "description": "<p>Function signature for the callback to render the section header at a given section index. \n</p>"
    }, 
    "TUPLE_UINT": {
        "kind": "enum", 
        "name": "TUPLE_UINT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The value is an unsigned integer. The tuple's .length field is used to determine the size of the integer (1, 2, or 4 bytes). </p>"
    }, 
    "atan2_lookup": {
        "kind": "fn", 
        "name": "atan2_lookup", 
        "return_desc": null, 
        "returns": "int32_t", 
        "warning": null, 
        "params": [
            {
                "type": "int16_t", 
                "name": "y", 
                "description": null
            }, 
            {
                "type": "int16_t", 
                "name": "x", 
                "description": null
            }
        ], 
        "description": "<p>Look-up the arctangent of a given x, y pair The angle value is scaled linearly, such that a value of 0x10000 corresponds to 360 degrees or 2 PI radians. </p>"
    }, 
    "APP_MESSAGE_INBOX_SIZE_MINIMUM": {
        "kind": "def", 
        "name": "APP_MESSAGE_INBOX_SIZE_MINIMUM", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>As long as the firmware maintains its current major version, inboxes of this size or smaller will be allowed.</p><p>\n</p>"
    }, 
    "bitmap_layer_set_compositing_mode": {
        "kind": "fn", 
        "name": "bitmap_layer_set_compositing_mode", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": "<p>The BitmapLayer for which to set the compositing mode </p>"
            }, 
            {
                "type": "GCompOp", 
                "name": "mode", 
                "description": "<p>The compositing mode to set </p>"
            }
        ], 
        "description": "<p>Sets the compositing mode of how the bitmap image is composited onto the BitmapLayer's background plane, or how it is composited onto what has been drawn beneath the BitmapLayer in case the background color is set to GColorClear.</p><p>The compositing mode only affects the drawing of the bitmap and not the drawing of the background color.</p><p>The bitmap layer is automatically marked dirty after this operation. \n</p>"
    }, 
    "GPointZero": {
        "kind": "def", 
        "name": "GPointZero", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Convenience macro to make a GPoint at (0, 0). </p>"
    }, 
    "clock_is_24h_style": {
        "kind": "fn", 
        "name": "clock_is_24h_style", 
        "return_desc": "<p>true if the user prefers 24h-style time display or false if the user prefers 12h-style time display. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [], 
        "description": "<p>Gets the user's 12/24h clock style preference."
    }, 
    "S_NO_ACTION_REQUIRED": {
        "kind": "enum", 
        "name": "S_NO_ACTION_REQUIRED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>No action was taken as none was required. </p>"
    }, 
    "BUTTON_ID_DOWN": {
        "kind": "enum", 
        "name": "BUTTON_ID_DOWN", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Down button. </p>"
    }, 
    "BatteryStateHandler": {
        "kind": "typedef", 
        "name": "BatteryStateHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback type for battery state change events"
    }, 
    "window_single_repeating_click_subscribe": {
        "kind": "fn", 
        "name": "window_single_repeating_click_subscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Must be called from within the ClickConfigProvider. </p><p><code>window_single_click_subscribe()</code> and <code>window_single_repeating_click_subscribe()</code> conflict, and cannot both be used on the same button. </p><p>The back button cannot be overridden with a repeating click. </p>", 
        "params": [
            {
                "type": "ButtonId", 
                "name": "button_id", 
                "description": null
            }, 
            {
                "type": "uint16_t", 
                "name": "repeat_interval_ms", 
                "description": "<p>When holding down, how many milliseconds before the handler is fired again. </p>"
            }, 
            {
                "type": "ClickHandler", 
                "name": "handler", 
                "description": null
            }
        ], 
        "description": "<p>Subscribe to single click event, with a repeat interval. A single click is detected every time \"<code>repeat_interval_ms</code>\" has been reached. <p>If there is a long-click handler subscribed on this button, <code>repeat_interval_ms</code> will not be used. </p>\n\n</p>"
    }, 
    "DictionarySerializeCallback": {
        "kind": "typedef", 
        "name": "DictionarySerializeCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback for <code>dict_serialize_tuplets()</code> utility. \n</p>"
    }, 
    "text_layer_set_size": {
        "kind": "fn", 
        "name": "text_layer_set_size", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the size </p>"
            }, 
            {
                "type": "GSize", 
                "name": "max_size", 
                "description": "<p>The new size for the TextLayer </p>"
            }
        ], 
        "description": "<p>Update the size of the text layer This is a convenience function to update the frame of the TextLayer."
    }, 
    "window_stack_pop": {
        "kind": "fn", 
        "name": "window_stack_pop", 
        "return_desc": "<p>The window that is popped, or NULL if there are no windows to pop. </p>", 
        "returns": "Window *", 
        "warning": null, 
        "params": [
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>See <code>window_stack_remove()</code> </p>"
            }
        ], 
        "description": "<p>Pops the topmost window on the navigation stack"
    }, 
    "SNIFF_INTERVAL_NORMAL": {
        "kind": "enum", 
        "name": "SNIFF_INTERVAL_NORMAL", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Set the sniff interval to normal (power-saving) mode. </p>"
    }, 
    "GCompOpOr": {
        "kind": "enum", 
        "name": "GCompOpOr", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Use the boolean operator OR to composite the source and destination pixels. The visual result of this compositing mode is the source's white pixels are painted onto the destination and the source's black pixels are treated as clear. </p>"
    }, 
    "fonts_get_system_font": {
        "kind": "fn", 
        "name": "fonts_get_system_font", 
        "return_desc": "<p>An opaque pointer to the loaded font, or, a pointer to the default (fallback) font if the specified font cannot be loaded. </p>", 
        "returns": "GFont", 
        "warning": "<p>This may load a font from the flash peripheral into RAM. </p>", 
        "params": [
            {
                "type": "const char *", 
                "name": "font_key", 
                "description": "<p>The string key of the font to load. See <code>pebble_fonts</code>.h for a list of system fonts. </p>"
            }
        ], 
        "description": "<p>Loads a system font corresponding to the specified font key."
    }, 
    "graphics_fill_rect": {
        "kind": "fn", 
        "name": "graphics_fill_rect", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle to fill </p>"
            }, 
            {
                "type": "uint16_t", 
                "name": "corner_radius", 
                "description": "<p>The rounding radius of the corners in pixels (maximum is 8 pixels) </p>"
            }, 
            {
                "type": "GCornerMask", 
                "name": "corner_mask", 
                "description": "<p>Bitmask of the corners that need to be rounded. </p>"
            }
        ], 
        "description": "<p>Fills a retangle with the current fill color, optionally rounding all or a selection of its corners \n</p>"
    }, 
    "graphics_draw_round_rect": {
        "kind": "fn", 
        "name": "graphics_draw_round_rect", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle defining the dimensions of the rounded rectangle to draw </p>"
            }, 
            {
                "type": "uint16_t", 
                "name": "radius", 
                "description": "<p>The corner radius in pixels </p>"
            }
        ], 
        "description": "<p>Draws the outline of a rounded rectangle in the current stroke color"
    }, 
    "AppSyncTupleChangedCallback": {
        "kind": "typedef", 
        "name": "AppSyncTupleChangedCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Called whenever a Tuple changes. This does not necessarily mean the value in the Tuple has changed. When the internal \"current\" dictionary gets updated, existing Tuples might get shuffled around in the backing buffer, even though the values stay the same. In this callback, the client code gets the chance to remove the old reference and start using the new one. In this callback, your application MUST clean up any references to the <code>old_tuple</code> of a PREVIOUS call to this callback (and replace it with the <code>new_tuple</code> that is passed in with the current call). \n</p>"
    }, 
    "persist_delete": {
        "kind": "fn", 
        "name": "persist_delete", 
        "return_desc": null, 
        "returns": "status_t", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to delete from. </p>"
            }
        ], 
        "description": "<p>Deletes the value of a key from persistent storage."
    }, 
    "fonts_load_custom_font": {
        "kind": "fn", 
        "name": "fonts_load_custom_font", 
        "return_desc": "<p>An opaque pointer to the loaded font, or a pointer to the default (fallback) font if the specified font cannot be loaded. </p>", 
        "returns": "GFont", 
        "warning": "<p>this may load a font from the flash peripheral into RAM. </p>", 
        "params": [
            {
                "type": "ResHandle", 
                "name": "resource", 
                "description": "<p>The resource handle of the font to load. See <code>resource_ids</code>.auto.h for a list of resource IDs, and use <code>resource_get_handle()</code> to obtain the resource handle. </p>"
            }
        ], 
        "description": "<p>Loads a custom font."
    }, 
    "dict_write_tuplet": {
        "kind": "fn", 
        "name": "dict_write_tuplet", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "Tuplet", 
                "name": "tuplet", 
                "description": "<p>The Tuplet describing the key/value pair to write </p>"
            }
        ], 
        "description": "<p>Serializes a Tuplet and writes the resulting Tuple into a dictionary."
    }, 
    "gpath_rotate_to": {
        "kind": "fn", 
        "name": "gpath_rotate_to", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Setting a rotation does not affect the points in the path directly. The rotation is applied on-the-fly during drawing, either using <code>gpath_draw_filled()</code> or <code>gpath_draw_outline()</code>. </p>", 
        "params": [
            {
                "type": "GPath", 
                "name": "path", 
                "description": "<p>The path onto which to set the rotation </p>"
            }, 
            {
                "type": "int32_t", 
                "name": "angle", 
                "description": "<p>The absolute angle of the rotation. The angle is represented in the same way that is used with <code>sin_lookup()</code>. See <code>TRIG_MAX_ANGLE</code> for more information. </p>"
            }
        ], 
        "description": "<p>Sets the absolute rotation of the path. The current rotation will be replaced by the specified angle."
    }, 
    "window_set_background_color": {
        "kind": "fn", 
        "name": "window_set_background_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the background color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "background_color", 
                "description": "<p>The new background color </p>"
            }
        ], 
        "description": "<p>Sets the background color of the window, which is drawn automatically by the root layer of the window. \n</p>"
    }, 
    "animation_destroy": {
        "kind": "fn", 
        "name": "animation_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": null
            }
        ], 
        "description": "<p>Destroys an Animation previously created by <code>animation_create</code>. </p>"
    }, 
    "persist_get_size": {
        "kind": "fn", 
        "name": "persist_get_size", 
        "return_desc": "<p>The size of the value in bytes or <code>E_DOES_NOT_EXIST</code> if there is no field matching the given key. </p>", 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to lookup the data size. </p>"
            }
        ], 
        "description": "<p>Gets the size of a value for a given key in persistent storage."
    }, 
    "GSize": {
        "kind": "typedef", 
        "name": "GSize", 
        "return_desc": null, 
        "returns": "GSize", 
        "warning": null, 
        "params": [], 
        "description": "<p>Represents a 2-dimensional size. </p>"
    }, 
    "rot_bitmap_set_compositing_mode": {
        "kind": "fn", 
        "name": "rot_bitmap_set_compositing_mode", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "RotBitmapLayer *", 
                "name": "image", 
                "description": null
            }, 
            {
                "type": "GCompOp", 
                "name": "mode", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "app_message_register_outbox_sent": {
        "kind": "fn", 
        "name": "app_message_register_outbox_sent", 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageOutboxSent", 
        "warning": null, 
        "params": [
            {
                "type": "AppMessageOutboxSent", 
                "name": "sent_callback", 
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>"
            }
        ], 
        "description": "<p>Registers a function that will be called after any Outbox message is sent and an ACK reply occurs in a timely fashion.</p><p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>"
    }, 
    "layer_destroy": {
        "kind": "fn", 
        "name": "layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Layer *", 
                "name": "layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a layer previously created by <code>layer_create</code>. </p>"
    }, 
    "AppFocusHandler": {
        "kind": "typedef", 
        "name": "AppFocusHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback type for focus events"
    }, 
    "scroll_layer_set_shadow_hidden": {
        "kind": "fn", 
        "name": "scroll_layer_set_shadow_hidden", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The scroll layer for which to set the shadow visibility </p>"
            }, 
            {
                "type": "bool", 
                "name": "hidden", 
                "description": "<p>Supply true to make the shadow hidden, or false to make it non-hidden. </p>"
            }
        ], 
        "description": "<p>Sets the visibility of the scroll layer shadow. If the visibility has changed, <code>layer_mark_dirty()</code> will be called automatically on the scroll layer."
    }, 
    "AccelDataHandler": {
        "kind": "typedef", 
        "name": "AccelDataHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback type for accelerometer data events"
    }, 
    "DATA_LOGGING_BUSY": {
        "kind": "enum", 
        "name": "DATA_LOGGING_BUSY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Someone else is writing to this logging session. </p>"
    }, 
    "action_bar_layer_add_to_window": {
        "kind": "fn", 
        "name": "action_bar_layer_add_to_window", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>After this call, do not use <code>window_set_click_config_provider_with_context()</code> with the window that the action bar has been added to (this would de-associate the action bar's click config provider and context). Instead use <code>action_bar_layer_set_click_config_provider()</code> and <code>action_bar_layer_set_context()</code> to register the click configuration provider to configure the buttons actions. </p><p>It is advised to call this is in the window's .load or .appear handler. Make sure to call <code>action_bar_layer_remove_from_window()</code> in the window's .unload or .disappear handler. </p><p>Adding additional layers to the window's root layer after this calll can occlude the action bar. </p>", 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar to associate with the window </p>"
            }, 
            {
                "type": "struct Window *", 
                "name": "window", 
                "description": "<p>The window with which the action bar is to be associated </p>"
            }
        ], 
        "description": "<p>Adds the action bar's layer on top of the window's root layer. It also adjusts the layout of the action bar to match the geometry of the window it gets added to. Lastly, it calls <code>window_set_click_config_provider_with_context()</code> on the window to set it up to work with the internal callback and raw click handlers of the action bar, to enable the highlighting of the section of the action bar when the user presses a button."
    }, 
    "text_layer_set_overflow_mode": {
        "kind": "fn", 
        "name": "text_layer_set_overflow_mode", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the overflow mode </p>"
            }, 
            {
                "type": "GTextOverflowMode", 
                "name": "line_mode", 
                "description": "<p>The new GTextOverflowMode to set </p>"
            }
        ], 
        "description": "<p>Sets the line break mode of the TextLayer"
    }, 
    "MenuCellSpan": {
        "kind": "typedef", 
        "name": "MenuCellSpan", 
        "return_desc": null, 
        "returns": "MenuCellSpan", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "AppMessageOutboxSent": {
        "kind": "typedef", 
        "name": "AppMessageOutboxSent", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Called after an outbound message has been sent and the reply has been received.</p><p>"
    }, 
    "APP_MSG_CALLBACK_ALREADY_REGISTERED": {
        "kind": "enum", 
        "name": "APP_MSG_CALLBACK_ALREADY_REGISTERED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The callback node was already registered, or its ListNode has not been initialized. </p>"
    }, 
    "DICT_MALLOC_FAILED": {
        "kind": "enum", 
        "name": "DICT_MALLOC_FAILED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>"
    }, 
    "AnimationHandlers": {
        "kind": "typedef", 
        "name": "AnimationHandlers", 
        "return_desc": null, 
        "returns": "AnimationHandlers", 
        "warning": null, 
        "params": [], 
        "description": "<p>The handlers that will get called when an animation starts and stops. See documentation with the function pointer types for more information. \n</p>"
    }, 
    "GCompOpAnd": {
        "kind": "enum", 
        "name": "GCompOpAnd", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Use the boolean operator AND to composite the source and destination pixels. The visual result of this compositing mode is the source's black pixels are painted onto the destination and the source's white pixels are treated as clear. </p>"
    }, 
    "scroll_layer_destroy": {
        "kind": "fn", 
        "name": "scroll_layer_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a ScrollLayer previously created by <code>scroll_layer_create</code>. </p>"
    }, 
    "GTextAlignmentCenter": {
        "kind": "enum", 
        "name": "GTextAlignmentCenter", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Aligns the text centered inside the drawing box. </p>"
    }, 
    "app_focus_service_unsubscribe": {
        "kind": "fn", 
        "name": "app_focus_service_unsubscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unscribe from the focus event service. Once unsubscribed, the previously registered handler will no longer be called. </p>"
    }, 
    "grect_align": {
        "kind": "fn", 
        "name": "grect_align", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The aligned and optionally clipped rectangle </p>"
            }, 
            {
                "type": "GRect", 
                "name": "inside_rect", 
                "description": "<p>The rectangle in which to align rect </p>"
            }, 
            {
                "type": "GAlign", 
                "name": "alignment", 
                "description": "<p>Determines the alignment of rect within <code>inside_rect</code> by specifying what edges of should overlap. </p>"
            }, 
            {
                "type": "const bool", 
                "name": "clip", 
                "description": "<p>Determines whether rect should be trimmed using the edges of <code>inside_rect</code> in case rect extends outside of the area that <code>inside_rect</code> covers after the alignment. </p>"
            }
        ], 
        "description": "<p>Aligns one rectangle within another rectangle, using an alignment parameter. The relative coordinate systems of both rectangles are assumed to be the same. When clip is true, rect is also clipped by the constraint."
    }, 
    "grect_contains_point": {
        "kind": "fn", 
        "name": "grect_contains_point", 
        "return_desc": "<p>true if the rectangle contains the point, or false if it does not. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "point", 
                "description": "<p>The point </p>"
            }
        ], 
        "description": "<p>Tests whether a rectangle contains a point."
    }, 
    "layer_create": {
        "kind": "fn", 
        "name": "layer_create", 
        "return_desc": "<p>A pointer to the layer. NULL if the layer could not be created </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": "<p>The frame at which the layer should be initialized. </p>"
            }
        ], 
        "description": "<p>Creates a layer on the heap and sets its frame and bounds. Default values:<ul><li><p>bounds : origin (0, 0) and a size equal to the frame that is passed in.</p></li><li><p>clips : true</p></li><li><p>hidden : false</p></li><li><p><code>update_proc</code> : NULL (draws nothing) \n</li></ul>\n</p>"
    }, 
    "persist_exists": {
        "kind": "fn", 
        "name": "persist_exists", 
        "return_desc": "<p>true if a value exists, otherwise false. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to check. </p>"
            }
        ], 
        "description": "<p>Checks whether a value has been set for a given key in persistent storage."
    }, 
    "APP_MSG_BUFFER_OVERFLOW": {
        "kind": "enum", 
        "name": "APP_MSG_BUFFER_OVERFLOW", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The buffer was too small to contain the incoming message. </p>"
    }, 
    "AnimationSetupImplementation": {
        "kind": "typedef", 
        "name": "AnimationSetupImplementation", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Pointer to function that (optionally) prepares the animation for running. This callback is called when the animation is added to the scheduler. \n</p>"
    }, 
    "APP_MSG_INTERNAL_ERROR": {
        "kind": "enum", 
        "name": "APP_MSG_INTERNAL_ERROR", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>An internal OS error prevented <code>APP_MSG</code> from completing an operation. </p>"
    }, 
    "GColorClear": {
        "kind": "enum", 
        "name": "GColorClear", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Represents \"clear\" or transparent. </p>"
    }, 
    "menu_cell_basic_draw": {
        "kind": "fn", 
        "name": "menu_cell_basic_draw", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context </p>"
            }, 
            {
                "type": "const Layer *", 
                "name": "cell_layer", 
                "description": "<p>The layer of the cell to draw </p>"
            }, 
            {
                "type": "const char *", 
                "name": "title", 
                "description": "<p>If non-null, draws a title in larger text (24 points, bold Raster Gothic system font). </p>"
            }, 
            {
                "type": "const char *", 
                "name": "subtitle", 
                "description": "<p>If non-null, draws a subtitle in smaller text (18 points, Raster Gothic system font). If NULL, the title will be centered vertically inside the menu cell. </p>"
            }, 
            {
                "type": "GBitmap *", 
                "name": "icon", 
                "description": "<p>If non-null, draws an icon to the left of the text. If NULL, the icon will be omitted and the leftover space is used for the title and subtitle. </p>"
            }
        ], 
        "description": "<p>Section drawing function to draw a basic section cell with the title, subtitle, and icon of the section. Call this function inside the .<code>draw_row</code> callback implementation, see MenuLayerCallbacks."
    }, 
    "window_destroy": {
        "kind": "fn", 
        "name": "window_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a Window previously created by <code>window_create</code>. </p>"
    }, 
    "window_set_window_handlers": {
        "kind": "fn", 
        "name": "window_set_window_handlers", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the window handlers </p>"
            }, 
            {
                "type": "WindowHandlers", 
                "name": "handlers", 
                "description": "<p>The handlers for the specified window </p>"
            }
        ], 
        "description": "<p>Sets the window handlers of the window. These handlers get called e.g. when the user enters or leaves the window. \n</p>"
    }, 
    "GAlignLeft": {
        "kind": "enum", 
        "name": "GAlignLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the left edges overlap and centered vertically. </p>"
    }, 
    "scroll_layer_set_frame": {
        "kind": "fn", 
        "name": "scroll_layer_set_frame", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to set the frame </p>"
            }, 
            {
                "type": "GRect", 
                "name": "frame", 
                "description": "<p>The new frame </p>"
            }
        ], 
        "description": "<p>Set the frame of the scroll layer and adjusts the internal layers' geometry accordingly. The scroll layer is marked dirty automatically."
    }, 
    "gpath_draw_outline": {
        "kind": "fn", 
        "name": "gpath_draw_outline", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The graphics context to draw into </p>"
            }, 
            {
                "type": "GPath", 
                "name": "path", 
                "description": "<p>The path to fill </p>"
            }
        ], 
        "description": "<p>Draws the outline of a path into a graphics context, using the current stroke color, relative to the drawing area as set up by the layering system. \n</p>"
    }, 
    "scroll_layer_add_child": {
        "kind": "fn", 
        "name": "scroll_layer_add_child", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>You may need to update the size of the scrollable contents using <code>scroll_layer_set_content_size()</code>. </p>", 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer to which to add the child layer. </p>"
            }, 
            {
                "type": "Layer *", 
                "name": "child", 
                "description": "<p>The Layer to add to the content sub-layer of the ScrollLayer. </p>"
            }
        ], 
        "description": "<p>Adds the child layer to the content sub-layer of the ScrollLayer. This will make the child layer part of the scrollable contents. The content sub-layer of the ScrollLayer will become the parent of the child layer."
    }, 
    "graphics_draw_bitmap_in_rect": {
        "kind": "fn", 
        "name": "graphics_draw_bitmap_in_rect", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the size of rect is smaller than the size of the bitmap, the bitmap will be clipped on right and bottom edges. If the size of rect is larger than the size of the bitmap, the bitmap will be tiled automatically in both horizontal and vertical directions, effectively drawing a repeating pattern. </p>", 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw the bitmap </p>"
            }, 
            {
                "type": "const GBitmap *", 
                "name": "bitmap", 
                "description": "<p>The bitmap to draw </p>"
            }, 
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle in which to draw the bitmap </p>"
            }
        ], 
        "description": "<p>Draws a bitmap into the graphics context, inside the specified rectangle \n</p>"
    }, 
    "GRectZero": {
        "kind": "def", 
        "name": "GRectZero", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Convenience macro to make a GRect of ((0, 0), (0, 0)). </p>"
    }, 
    "data_logging_finish": {
        "kind": "fn", 
        "name": "data_logging_finish", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "DataLoggingSessionRef", 
                "name": "logging_session", 
                "description": "<p>a reference to the data logging session previously allocated using <code>data_logging_create</code> </p>"
            }
        ], 
        "description": "<p>Delete a data <code>logging_session</code>. Logging data is kept until it has successfully been transferred over to the phone, but no data may be added to the session after this function is called.</p><p>"
    }, 
    "action_bar_layer_remove_from_window": {
        "kind": "fn", 
        "name": "action_bar_layer_remove_from_window", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar to de-associate from its current window </p>"
            }
        ], 
        "description": "<p>Removes the action bar from the window and unconfigures the window's click configuration provider. NULL is set as the window's new click config provider and also as its callback context. If it has not been added to a window before, this function is a no-op."
    }, 
    "BitmapLayer": {
        "kind": "typedef", 
        "name": "BitmapLayer", 
        "return_desc": null, 
        "returns": "struct BitmapLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "property_animation_create": {
        "kind": "fn", 
        "name": "property_animation_create", 
        "return_desc": "<p>A pointer to the property animation. NULL if animation could not be created </p>", 
        "returns": "PropertyAnimation", 
        "warning": "<p>Pass in NULL as one of the value arguments to have it set automatically to the subject's current property value, as returned by the getter function. Also note that passing in NULL for both <code>from_value</code> and <code>to_value</code>, will result in the animation having the same from- and to- values, effectively not doing anything. </p>", 
        "params": [
            {
                "type": "PropertyAnimationImplementation", 
                "name": "implementation", 
                "description": "<p>Pointer to the implementation of the animation. In most cases, it makes sense to pass in a static const struct pointer. </p>"
            }, 
            {
                "type": "void *", 
                "name": "subject", 
                "description": "<p>Pointer to the \"subject\" being animated. This will be passed in when the getter/setter accessors are called, see PropertyAnimationAccessors, GPointSetter, and friends. The value of this pointer will be copied into the .subject field of the PropertyAnimation struct. </p>"
            }, 
            {
                "type": "void *", 
                "name": "from_value", 
                "description": "<p>Pointer to the value that the subject should animate from </p>"
            }, 
            {
                "type": "void *", 
                "name": "to_value", 
                "description": "<p>Pointer to the value that the subject should animate to </p>"
            }
        ], 
        "description": "<p>Creates a new PropertyAnimation on the heap and and initializes it with the specified values. The same defaults are used as with <code>animation_create()</code>. If the <code>from_value</code> or the <code>to_value</code> is NULL, the getter accessor will be called to get the current value of the property and be used instead."
    }, 
    "accel_tap_service_unsubscribe": {
        "kind": "fn", 
        "name": "accel_tap_service_unsubscribe", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Unsubscribe from the accelerometer tap event service. Once unsubscribed, the previously registered handler will no longer be called. </p>"
    }, 
    "MenuLayerDrawRowCallback": {
        "kind": "typedef", 
        "name": "MenuLayerDrawRowCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>The <code>cell_layer</code> argument is provided to make it easy to re-use an .<code>update_proc</code> implementation in this callback. Only the bounds and frame of the <code>cell_layer</code> are actually valid and other properties should be ignored. </p>", 
        "params": [], 
        "description": "<p>Function signature for the callback to render the menu cell at a given MenuIndex. \n</p>"
    }, 
    "app_message_set_context": {
        "kind": "fn", 
        "name": "app_message_set_context", 
        "return_desc": "<p>The previous context that was on record. </p>", 
        "returns": "void *", 
        "warning": null, 
        "params": [
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>The context that will be passed to all AppMessage callbacks.</p>"
            }
        ], 
        "description": "<p>Sets the context that will be passed to all AppMessage callbacks.</p><p>"
    }, 
    "BUTTON_ID_UP": {
        "kind": "enum", 
        "name": "BUTTON_ID_UP", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Up button. </p>"
    }, 
    "simple_menu_layer_get_layer": {
        "kind": "fn", 
        "name": "simple_menu_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the menu layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "const SimpleMenuLayer *", 
                "name": "simple_menu", 
                "description": "<p>Pointer to the SimpleMenuLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the simple menu layer, which is the parent for the sub-layers used for its implementation."
    }, 
    "BUTTON_ID_SELECT": {
        "kind": "enum", 
        "name": "BUTTON_ID_SELECT", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Select (middle) button. </p>"
    }, 
    "grect_is_empty": {
        "kind": "fn", 
        "name": "grect_is_empty", 
        "return_desc": "<p>true if the rectangle its size is (0, 0), or false if not. </p>", 
        "returns": "bool", 
        "warning": "<p>If the width and/or height of a rectangle is negative, this function will return true! </p>", 
        "params": [
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>Pointer to the rectangle </p>"
            }
        ], 
        "description": "<p>Tests whether the size of the rectangle is (0, 0)."
    }, 
    "vibes_cancel": {
        "kind": "fn", 
        "name": "vibes_cancel", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Cancel any in-flight vibe patterns; this is a no-op if there is no on-going vibe. </p>"
    }, 
    "dict_write_int32": {
        "kind": "fn", 
        "name": "dict_write_int32", 
        "return_desc": null, 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": null
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": null
            }, 
            {
                "type": "const int32_t", 
                "name": "value", 
                "description": null
            }
        ], 
        "description": ""
    }, 
    "S_FALSE": {
        "kind": "enum", 
        "name": "S_FALSE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Equivalent of boolean false. </p>"
    }, 
    "grect_center_point": {
        "kind": "fn", 
        "name": "grect_center_point", 
        "return_desc": "<p>The point at the center of rect </p>", 
        "returns": "GPoint", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "rect", 
                "description": "<p>The rectangle for which to calculate the center point. </p>"
            }
        ], 
        "description": "<p>Convenience function to compute the center-point of a given rectangle. This is equal to (rect->x + rect->width / 2, rect->y + rect->height / 2)."
    }, 
    "GAlignTop": {
        "kind": "enum", 
        "name": "GAlignTop", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by making the top edges overlap and centered horizontally. </p>"
    }, 
    "S_NO_MORE_ITEMS": {
        "kind": "enum", 
        "name": "S_NO_MORE_ITEMS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>For list-style requests. At end of list. </p>"
    }, 
    "battery_state_service_peek": {
        "kind": "fn", 
        "name": "battery_state_service_peek", 
        "return_desc": "<p>a BatterChargeState containing the last known data </p>", 
        "returns": "BatteryChargeState", 
        "warning": null, 
        "params": [], 
        "description": "<p>Peek at the last known battery state."
    }, 
    "E_ERROR": {
        "kind": "enum", 
        "name": "E_ERROR", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>An error occurred (no description). </p>"
    }, 
    "gsize_equal": {
        "kind": "fn", 
        "name": "gsize_equal", 
        "return_desc": "<p>true if both sizes are equal, false if not. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "GSize", 
                "name": "size_a", 
                "description": "<p>Pointer to the first size </p>"
            }, 
            {
                "type": "GSize", 
                "name": "size_b", 
                "description": "<p>Pointer to the second size </p>"
            }
        ], 
        "description": "<p>Tests whether 2 sizes are equal."
    }, 
    "MenuRowAlignTop": {
        "kind": "enum", 
        "name": "MenuRowAlignTop", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Scroll the contents of the MenuLayer in such way that the selected row is at the top of the visible area. </p>"
    }, 
    "WindowHandler": {
        "kind": "typedef", 
        "name": "WindowHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for a handler that deals with transition events of a window. \n</p>"
    }, 
    "window_set_user_data": {
        "kind": "fn", 
        "name": "window_set_user_data", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set the user data </p>"
            }, 
            {
                "type": "void *", 
                "name": "data", 
                "description": null
            }
        ], 
        "description": "<p>Sets a pointer to developer-supplied data that the window uses, to provide a means to access the data at later times in one of the window event handlers."
    }, 
    "scroll_layer_set_content_offset": {
        "kind": "fn", 
        "name": "scroll_layer_set_content_offset", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>When scrolling down, the offset's .y decrements. When scrolling up, the offset's .y increments. If scrolled completely to the top, the offset is GPointZero. </p><p>The .x field must be 0. Horizontal scrolling is not supported. </p>", 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to set the content offset </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "offset", 
                "description": "<p>The final content offset </p>"
            }, 
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>Pass in true to animate to the new content offset, or false to set the new content offset without animating. </p>"
            }
        ], 
        "description": "<p>Scrolls to the given offset, optionally animated. \n</p>"
    }, 
    "time_ms": {
        "kind": "fn", 
        "name": "time_ms", 
        "return_desc": "<p>Current Unix Time milliseconds portion </p>", 
        "returns": "uint16_t", 
        "warning": null, 
        "params": [
            {
                "type": "time_t *", 
                "name": "tloc", 
                "description": "<p>if provided receives current Unix Time seconds portion </p>"
            }, 
            {
                "type": "uint16_t *", 
                "name": "out_ms", 
                "description": "<p>if provided receives current Unix Time milliseconds portion </p>"
            }
        ], 
        "description": "<p>Returns the current time in Unix Timestamp Format with Milliseconds"
    }, 
    "animation_schedule": {
        "kind": "fn", 
        "name": "animation_schedule", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the animation was already scheduled, it will first unschedule it and then re-schedule it again. Note that in that case, the animation's .stopped handler, the implementation's .teardown and .setup will get called, due to the unscheduling and scheduling. </p>", 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation to schedule. </p>"
            }
        ], 
        "description": "<p>Schedules the animation. Call this once after configuring an animation to get it to start running.</p><p>If the animation's implementation has a .setup callback it will get called before this function returns.</p><p>\n</p>"
    }, 
    "menu_layer_set_selected_next": {
        "kind": "fn", 
        "name": "menu_layer_set_selected_next", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If there is no next/previous item, this function is a no-op. </p>", 
        "params": [
            {
                "type": "MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>The MenuLayer for which to select the next item </p>"
            }, 
            {
                "type": "bool", 
                "name": "up", 
                "description": "<p>Supply false to select the next item in the list (downwards), or true to select the previous item in the list (upwards). </p>"
            }, 
            {
                "type": "MenuRowAlign", 
                "name": "scroll_align", 
                "description": "<p>The alignment of the new selection </p>"
            }, 
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>Supply true to animate changing the selection, or false to change the selection instantly. </p>"
            }
        ], 
        "description": "<p>Selects the next or previous item, relative to the current selection."
    }, 
    "ClickConfigProvider": {
        "kind": "typedef", 
        "name": "ClickConfigProvider", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>This callback gets called at times that a click recognizer has to be set up, for example when a new window comes into view. Subscribe to click events using <code>window_single_click_subscribe()</code> <code>window_single_repeating_click_subscribe()</code> <code>window_multi_click_subscribe()</code> <code>window_long_click_subscribe()</code> <code>window_raw_click_subscribe()</code> These subscriptions will get used by the click recognizers of each of the 4 buttons."
    }, 
    "animation_set_duration": {
        "kind": "fn", 
        "name": "animation_set_duration", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation for which to set the duration. </p>"
            }, 
            {
                "type": "uint32_t", 
                "name": "duration_ms", 
                "description": "<p>The duration in milliseconds of the animation. This excludes any optional delay as set using <code>animation_set_delay()</code>. </p>"
            }
        ], 
        "description": "<p>Sets the time in milliseconds that an animation takes from start to finish."
    }, 
    "GTextOverflowModeTrailingEllipsis": {
        "kind": "enum", 
        "name": "GTextOverflowModeTrailingEllipsis", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>On overflow, wrap words to a new line below the current one. Once vertical space is consumed, truncate as needed to fit a trailing ellipsis (...). Clipping may occur if the vertical space cannot accomodate the first line of text. </p>"
    }, 
    "app_message_open": {
        "kind": "fn", 
        "name": "app_message_open", 
        "return_desc": "<p>A result code such as <code>APP_MSG_OK</code> or <code>APP_MSG_OUT_OF_MEMORY</code>.</p>", 
        "returns": "AppMessageResult", 
        "warning": "<p>It is recommended that if the Inbox will be used, that at least the Inbox callbacks should be registered before this call. Otherwise it is possible for an Inbox message to be NACK'ed without being seen by the application. </p>", 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "size_inbound", 
                "description": "<p>The required size for the Inbox buffer </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "size_outbound", 
                "description": "<p>The required size for the Outbox buffer</p>"
            }
        ], 
        "description": "<p>Open AppMessage to transfers.</p><p>Use <code>dict_calc_buffer_size_from_tuplets()</code> or <code>dict_calc_buffer_size()</code> to estimate the size you need.</p><p>"
    }, 
    "ANIMATION_NORMALIZED_MIN": {
        "kind": "def", 
        "name": "ANIMATION_NORMALIZED_MIN", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The normalized time at the start of the animation. </p>"
    }, 
    "text_layer_set_background_color": {
        "kind": "fn", 
        "name": "text_layer_set_background_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>The TextLayer of which to set the background color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "color", 
                "description": "<p>The new GColor to set the background to </p>"
            }
        ], 
        "description": "<p>Sets the background color of bounding box that will be drawn behind the text \n</p>"
    }, 
    "dict_write_data": {
        "kind": "fn", 
        "name": "dict_write_data", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>The data will be copied into the backing storage of the dictionary. </p><p>There is no checking for duplicate keys. </p>", 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key </p>"
            }, 
            {
                "type": "const uint8_t *const", 
                "name": "data", 
                "description": "<p>Pointer to the byte array </p>"
            }, 
            {
                "type": "const uint16_t", 
                "name": "size", 
                "description": "<p>Length of the byte array </p>"
            }
        ], 
        "description": "<p>Adds a key with a byte array value pair to the dictionary."
    }, 
    "menu_layer_set_callbacks": {
        "kind": "fn", 
        "name": "menu_layer_set_callbacks", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>Pointer to the MenuLayer for which to set the callbacks and callback context. </p>"
            }, 
            {
                "type": "void *", 
                "name": "callback_context", 
                "description": "<p>The new callback context. This is passed into each of the callbacks and can be set to point to application provided data. </p>"
            }, 
            {
                "type": "MenuLayerCallbacks", 
                "name": "callbacks", 
                "description": "<p>The new callbacks for the MenuLayer. The storage for this data structure must be long lived. Therefore, it cannot be stack-allocated. </p>"
            }
        ], 
        "description": "<p>Sets the callbacks for the MenuLayer. \n</p>"
    }, 
    "GRect": {
        "kind": "typedef", 
        "name": "GRect", 
        "return_desc": null, 
        "returns": "GRect", 
        "warning": null, 
        "params": [], 
        "description": "<p>Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size. </p>"
    }, 
    "GPointSetter": {
        "kind": "typedef", 
        "name": "GPointSetter", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of a setter function to set a property of type GPoint onto the subject. \n</p>"
    }, 
    "app_sync_init": {
        "kind": "fn", 
        "name": "app_sync_init", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>Only updates for the keys specified in this initial array will be accepted by AppSync, updates for other keys that might come in will just be ignored. </p>", 
        "params": [
            {
                "type": "AppSync", 
                "name": "s", 
                "description": "<p>The AppSync context to initialize </p>"
            }, 
            {
                "type": "uint8_t *", 
                "name": "buffer", 
                "description": "<p>The buffer that AppSync should use </p>"
            }, 
            {
                "type": "const uint16_t", 
                "name": "buffer_size", 
                "description": "<p>The size of the backing storage of the \"current\" dictionary. Use <code>dict_calc_buffer_size_from_tuplets()</code> to estimate the size you need. </p>"
            }, 
            {
                "type": "Tuplet", 
                "name": "keys_and_initial_values", 
                "description": "<p>An array of Tuplets with the initial keys and values. </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "count", 
                "description": "<p>The number of Tuplets in the <code>keys_and_initial_values</code> array. </p>"
            }, 
            {
                "type": "AppSyncTupleChangedCallback", 
                "name": "tuple_changed_callback", 
                "description": "<p>The callback that will handle changed key/value pairs </p>"
            }, 
            {
                "type": "AppSyncErrorCallback", 
                "name": "error_callback", 
                "description": "<p>The callback that will handle errors </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>Pointer to app specific data that will get passed into calls to the callbacks </p>"
            }
        ], 
        "description": "<p>Initialized an AppSync system with specific buffer size and initial keys and values. The callback.<code>value_changed</code> callback will be called asynchronously with the initial keys and values, as to avoid duplicating code to update your app's UI."
    }, 
    "resource_get_handle": {
        "kind": "fn", 
        "name": "resource_get_handle", 
        "return_desc": null, 
        "returns": "ResHandle", 
        "warning": null, 
        "params": [
            {
                "type": "uint32_t", 
                "name": "resource_id", 
                "description": null
            }
        ], 
        "description": "<p>Gets the resource handle for a file identifier."
    }, 
    "text_layer_get_content_size": {
        "kind": "fn", 
        "name": "text_layer_get_content_size", 
        "return_desc": "<p>The size occupied by the current text of the TextLayer </p>", 
        "returns": "GSize", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>the TextLayer for which to calculate the text's size </p>"
            }
        ], 
        "description": "<p>Calculates the size occupied by the current text of the TextLayer"
    }, 
    "action_bar_layer_set_background_color": {
        "kind": "fn", 
        "name": "action_bar_layer_set_background_color", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar of which to set the background color </p>"
            }, 
            {
                "type": "GColor", 
                "name": "background_color", 
                "description": "<p>The new background color </p>"
            }
        ], 
        "description": "<p>Sets the background color of the action bar. Defaults to GColorBlack. The action bar's layer is automatically marked dirty."
    }, 
    "action_bar_layer_set_context": {
        "kind": "fn", 
        "name": "action_bar_layer_set_context", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>By default, a pointer to the action bar itself is passed in, if the context has not been set or if it has been set to NULL. </p>", 
        "params": [
            {
                "type": "ActionBarLayer *", 
                "name": "action_bar", 
                "description": "<p>The action bar for which to assign the new context </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>The new context </p>"
            }
        ], 
        "description": "<p>Sets the context parameter, which will be passed in to ClickHandler callbacks and the ClickConfigProvider callback of the action bar. \n</p>"
    }, 
    "GAlignCenter": {
        "kind": "enum", 
        "name": "GAlignCenter", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Align by centering. </p>"
    }, 
    "DataLoggingSessionRef": {
        "kind": "typedef", 
        "name": "DataLoggingSessionRef", 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "menu_layer_set_selected_index": {
        "kind": "fn", 
        "name": "menu_layer_set_selected_index", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>If the section and/or row index exceeds the avaible number of sections or resp. rows, the exceeding index/indices will be capped, effectively selecting the last section and/or row, resp. </p>", 
        "params": [
            {
                "type": "MenuLayer *", 
                "name": "menu_layer", 
                "description": "<p>The MenuLayer for which to change the selection </p>"
            }, 
            {
                "type": "MenuIndex", 
                "name": "index", 
                "description": "<p>The index of the item to select </p>"
            }, 
            {
                "type": "MenuRowAlign", 
                "name": "scroll_align", 
                "description": "<p>The alignment of the new selection </p>"
            }, 
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>Supply true to animate changing the selection, or false to change the selection instantly. </p>"
            }
        ], 
        "description": "<p>Selects the item with given MenuIndex."
    }, 
    "GCompOpSet": {
        "kind": "enum", 
        "name": "GCompOpSet", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Sets the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is black, the destination image will be painted white. Other parts will be left untouched. </p>"
    }, 
    "app_message_register_inbox_received": {
        "kind": "fn", 
        "name": "app_message_register_inbox_received", 
        "return_desc": "<p>The previous callback (or NULL) that was on record. </p>", 
        "returns": "AppMessageInboxReceived", 
        "warning": null, 
        "params": [
            {
                "type": "AppMessageInboxReceived", 
                "name": "received_callback", 
                "description": "<p>The callback that will be called going forward; NULL to not have a callback.</p>"
            }
        ], 
        "description": "<p>Registers a function that will be called after any Inbox message is received successfully.</p><p>Only one callback may be registered at a time. Each subsequent call to this function will replace the previous callback. The callback is optional; setting it to NULL will deregister the current callback and no function will be called anymore.</p><p>"
    }, 
    "vibes_short_pulse": {
        "kind": "fn", 
        "name": "vibes_short_pulse", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Makes the watch emit one short vibration. </p>"
    }, 
    "S_TRUE": {
        "kind": "enum", 
        "name": "S_TRUE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Equivalent of boolean true. </p>"
    }, 
    "scroll_layer_get_content_size": {
        "kind": "fn", 
        "name": "scroll_layer_get_content_size", 
        "return_desc": null, 
        "returns": "GSize", 
        "warning": null, 
        "params": [
            {
                "type": "const ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to get the content size </p>"
            }
        ], 
        "description": "<p>Gets the size of the contents layer. \n</p>"
    }, 
    "number_window_destroy": {
        "kind": "fn", 
        "name": "number_window_destroy", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "NumberWindow *", 
                "name": "number_window", 
                "description": null
            }
        ], 
        "description": "<p>Destroys a NumberWindow previously created by <code>number_window_create</code>. </p>"
    }, 
    "GRectGetter": {
        "kind": "typedef", 
        "name": "GRectGetter", 
        "return_desc": null, 
        "returns": "GRectReturn", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature of a getter function to get the current property of type GRect of the subject. \n</p>"
    }, 
    "persist_read_int": {
        "kind": "fn", 
        "name": "persist_read_int", 
        "return_desc": "<p>The int value of the key to read from. </p>", 
        "returns": "int32_t", 
        "warning": "<p>The int is a signed 32-bit integer. If the value has not yet been set, this will return 0. </p>", 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to read from. </p>"
            }
        ], 
        "description": "<p>Reads an int value for a given key from persistent storage."
    }, 
    "GCornersLeft": {
        "kind": "enum", 
        "name": "GCornersLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Left corners. </p>"
    }, 
    "persist_read_data": {
        "kind": "fn", 
        "name": "persist_read_data", 
        "return_desc": "<p>The number of bytes written into the buffer or <code>E_DOES_NOT_EXIST</code> if there is no field matching the given key. </p>", 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to read from. </p>"
            }, 
            {
                "type": "void *", 
                "name": "buffer", 
                "description": "<p>The pointer to a buffer to be written to. </p>"
            }, 
            {
                "type": "const size_t", 
                "name": "buffer_size", 
                "description": "<p>The maximum size of the given buffer. </p>"
            }
        ], 
        "description": "<p>Reads a blob of data for a given key from persistent storage into a given buffer. If the value has not yet been set, the given buffer is left unchanged."
    }, 
    "APP_LOG_LEVEL_ERROR": {
        "kind": "enum", 
        "name": "APP_LOG_LEVEL_ERROR", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Error level log message. </p>"
    }, 
    "gbitmap_create_with_resource": {
        "kind": "fn", 
        "name": "gbitmap_create_with_resource", 
        "return_desc": "<p>A pointer to the GBitmap. NULL if the GBitmap could not be created </p>", 
        "returns": "GBitmap *", 
        "warning": null, 
        "params": [
            {
                "type": "uint32_t", 
                "name": "resource_id", 
                "description": "<p>The ID of the bitmap resource to load </p>"
            }
        ], 
        "description": "<p>Creates a new GBitmap on the heap using a Pebble image file stored as a resource. The resulting GBitmap must be destroyed using <code>gbitmap_destroy</code>."
    }, 
    "scroll_layer_get_content_offset": {
        "kind": "fn", 
        "name": "scroll_layer_get_content_offset", 
        "return_desc": null, 
        "returns": "GPoint", 
        "warning": null, 
        "params": [
            {
                "type": "ScrollLayer *", 
                "name": "scroll_layer", 
                "description": "<p>The ScrollLayer for which to get the content offset </p>"
            }
        ], 
        "description": "<p>Gets the point by which the contents are offset. \n</p>"
    }, 
    "AppTimer": {
        "kind": "typedef", 
        "name": "AppTimer", 
        "return_desc": null, 
        "returns": "struct AppTimer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "IS_SIGNED": {
        "kind": "def", 
        "name": "IS_SIGNED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "MenuLayerSelectionChangedCallback": {
        "kind": "typedef", 
        "name": "MenuLayerSelectionChangedCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to handle a change in the current selected item in the menu. \n</p>"
    }, 
    "GCornerNone": {
        "kind": "enum", 
        "name": "GCornerNone", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>No corners. </p>"
    }, 
    "AppSync": {
        "kind": "typedef", 
        "name": "AppSync", 
        "return_desc": null, 
        "returns": "AppSync", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "APP_MESSAGE_OUTBOX_SIZE_MINIMUM": {
        "kind": "def", 
        "name": "APP_MESSAGE_OUTBOX_SIZE_MINIMUM", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>As long as the firmware maintains its current major version, outboxes of this size or smaller will be allowed.</p><p>\n</p>"
    }, 
    "persist_read_bool": {
        "kind": "fn", 
        "name": "persist_read_bool", 
        "return_desc": "<p>The bool value of the key to read from. </p>", 
        "returns": "bool", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to read from. </p>"
            }
        ], 
        "description": "<p>Reads a bool value for a given key from persistent storage. If the value has not yet been set, this will return false."
    }, 
    "ClickRecognizerRef": {
        "kind": "typedef", 
        "name": "ClickRecognizerRef", 
        "return_desc": null, 
        "returns": "void *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Reference to opaque click recognizer When a ClickHandler callback is called, the recognizer that fired the handler is passed in. \n</p>"
    }, 
    "InverterLayer": {
        "kind": "typedef", 
        "name": "InverterLayer", 
        "return_desc": null, 
        "returns": "struct InverterLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "vibes_long_pulse": {
        "kind": "fn", 
        "name": "vibes_long_pulse", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [], 
        "description": "<p>Makes the watch emit one long vibration. </p>"
    }, 
    "dict_serialize_tuplets": {
        "kind": "fn", 
        "name": "dict_serialize_tuplets", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>The callback will be called before the function returns, so the data that that context points to, can be stack allocated. </p>", 
        "params": [
            {
                "type": "DictionarySerializeCallback", 
                "name": "callback", 
                "description": "<p>The callback that will be called with the serialized data of the generated dictionary. </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>Pointer to any application specific data that gets passed into the callback. </p>"
            }, 
            {
                "type": "Tuplet", 
                "name": "tuplets", 
                "description": "<p>An array of Tuplets that need to be serialized into the dictionary. </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "tuplets_count", 
                "description": "<p>The number of tuplets that follow. </p>"
            }
        ], 
        "description": "<p>Utility function that takes a list of Tuplets from which a dictionary will be serialized, ready to transmit or store."
    }, 
    "PropertyAnimationImplementation": {
        "kind": "typedef", 
        "name": "PropertyAnimationImplementation", 
        "return_desc": null, 
        "returns": "PropertyAnimationImplementation", 
        "warning": null, 
        "params": [], 
        "description": "<p>Data structure containing a collection of function pointers that form the implementation of the property animation. See the code example at the top (PropertyAnimation). </p>"
    }, 
    "window_stack_remove": {
        "kind": "fn", 
        "name": "window_stack_remove", 
        "return_desc": "<p>True if window was successfully removed, false otherwise. </p>", 
        "returns": "bool", 
        "warning": "<p>If there are no windows for the app left on the stack, the app will be killed by the system, shortly. To avoid this, make sure to push another window shortly after or before removing the last window. </p>", 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window to remove. If the window is NULL or if it is not on the stack, this function is a no-op. </p>"
            }, 
            {
                "type": "bool", 
                "name": "animated", 
                "description": "<p>Pass in true to animate the removal of the window using a side-to-side sliding animation to reveal the next window. This is only used in case the window happens to be on top of the window stack (thus visible). </p>"
            }
        ], 
        "description": "<p>Removes a given window from the window stack that belongs to the app task."
    }, 
    "E_BUSY": {
        "kind": "enum", 
        "name": "E_BUSY", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Another operation prevented this one. </p>"
    }, 
    "SimpleMenuLayerSelectCallback": {
        "kind": "typedef", 
        "name": "SimpleMenuLayerSelectCallback", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to handle the event that a user hits the SELECT button."
    }, 
    "persist_write_int": {
        "kind": "fn", 
        "name": "persist_write_int", 
        "return_desc": null, 
        "returns": "status_t", 
        "warning": "<p>The int is a signed 32-bit integer. </p>", 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to write to. </p>"
            }, 
            {
                "type": "const int32_t", 
                "name": "value", 
                "description": "<p>The int value to write. </p>"
            }
        ], 
        "description": "<p>Writes an int value for a given key into persistent storage."
    }, 
    "NUM_ANIMATION_CURVE": {
        "kind": "def", 
        "name": "NUM_ANIMATION_CURVE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "MenuLayerCallbacks": {
        "kind": "typedef", 
        "name": "MenuLayerCallbacks", 
        "return_desc": null, 
        "returns": "MenuLayerCallbacks", 
        "warning": null, 
        "params": [], 
        "description": "<p>Data structure containing all the callbacks of a MenuLayer. </p>"
    }, 
    "GAlign": {
        "kind": "typedef", 
        "name": "GAlign", 
        "return_desc": null, 
        "returns": "GAlign", 
        "warning": null, 
        "params": [], 
        "description": "<p>Values to specify how two things should be aligned relative to each other. \n \n</p>"
    }, 
    "window_get_root_layer": {
        "kind": "fn", 
        "name": "window_get_root_layer", 
        "return_desc": "<p>The window's root layer </p>", 
        "returns": "struct Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "const Window *", 
                "name": "window", 
                "description": "<p>The window for which to get the root layer </p>"
            }
        ], 
        "description": "<p>Gets the root Layer of the window. The root layer is the layer at the bottom of the layer hierarchy for this window. It is the window's \"canvas\" if you will. By default, the root layer only draws a solid fill with the window's background color."
    }, 
    "scroll_layer_scroll_up_click_handler": {
        "kind": "fn", 
        "name": "scroll_layer_scroll_up_click_handler", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This handler is exposed, in case one wants to implement an alternative handler for the UP button, as a way to invoke the default behavior. </p>", 
        "params": [
            {
                "type": "ClickRecognizerRef", 
                "name": "recognizer", 
                "description": "<p>The click recognizer for which the handler is called </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>A void pointer to the ScrollLayer that is the context of the click event </p>"
            }
        ], 
        "description": "<p>The click handlers for the UP button that the scroll layer will install as part of <code>scroll_layer_set_click_config_onto_window()</code>."
    }, 
    "text_layer_get_layer": {
        "kind": "fn", 
        "name": "text_layer_get_layer", 
        "return_desc": "<p>The \"root\" Layer of the text layer. </p>", 
        "returns": "Layer *", 
        "warning": null, 
        "params": [
            {
                "type": "TextLayer *", 
                "name": "text_layer", 
                "description": "<p>Pointer to the TextLayer for which to get the \"root\" Layer </p>"
            }
        ], 
        "description": "<p>Gets the \"root\" Layer of the text layer, which is the parent for the sub- layers used for its implementation."
    }, 
    "E_DOES_NOT_EXIST": {
        "kind": "enum", 
        "name": "E_DOES_NOT_EXIST", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Target of operation does not exist. </p>"
    }, 
    "APP_MSG_INVALID_ARGS": {
        "kind": "enum", 
        "name": "APP_MSG_INVALID_ARGS", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The function was called with invalid arguments. </p>"
    }, 
    "BluetoothConnectionHandler": {
        "kind": "typedef", 
        "name": "BluetoothConnectionHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Callback type for bluetooth connection events"
    }, 
    "AnimationCurveEaseOut": {
        "kind": "enum", 
        "name": "AnimationCurveEaseOut", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Bicubic ease-in: decelerate to zero velocity. </p>"
    }, 
    "dict_write_uint8": {
        "kind": "fn", 
        "name": "dict_write_uint8", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> or <code>DICT_INVALID_ARGS</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": "<p>There is no checking for duplicate keys. </p><p>There are counterpart functions for different signedness and widths, <code>dict_write_uint16()</code>, <code>dict_write_uint32()</code>, <code>dict_write_int8()</code>, <code>dict_write_int16()</code> and <code>dict_write_int32()</code>. The documentation is not repeated for brevity's sake. </p>", 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "iter", 
                "description": "<p>The dictionary iterator </p>"
            }, 
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key </p>"
            }, 
            {
                "type": "const uint8_t", 
                "name": "value", 
                "description": "<p>The unsigned, 8-bit integer value </p>"
            }
        ], 
        "description": "<p>Adds a key with an unsigned, 8-bit integer value pair to the dictionary."
    }, 
    "rot_bitmap_layer_set_angle": {
        "kind": "fn", 
        "name": "rot_bitmap_layer_set_angle", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "RotBitmapLayer *", 
                "name": "image", 
                "description": null
            }, 
            {
                "type": "int32_t", 
                "name": "angle", 
                "description": null
            }
        ], 
        "description": "<p>sets rotation to the given angle </p>"
    }, 
    "persist_write_string": {
        "kind": "fn", 
        "name": "persist_write_string", 
        "return_desc": "<p>The number of bytes written. </p>", 
        "returns": "int", 
        "warning": null, 
        "params": [
            {
                "type": "const uint32_t", 
                "name": "key", 
                "description": "<p>The key of the field to write to. </p>"
            }, 
            {
                "type": "const char *", 
                "name": "cstring", 
                "description": "<p>The pointer to null terminated string. </p>"
            }
        ], 
        "description": "<p>Writes a string a given key into persistent storage. The maximum size is <code>PERSIST_STRING_MAX_LENGTH</code> including the null terminator."
    }, 
    "MenuLayerGetNumberOfRowsInSectionsCallback": {
        "kind": "typedef", 
        "name": "MenuLayerGetNumberOfRowsInSectionsCallback", 
        "return_desc": "<p>The number of rows in the given section in the menu </p>", 
        "returns": "uint16_t(*", 
        "warning": null, 
        "params": [], 
        "description": "<p>Function signature for the callback to get the number of rows in a given section in a menu. \n</p>"
    }, 
    "resource_load": {
        "kind": "fn", 
        "name": "resource_load", 
        "return_desc": "<p>The number of bytes actually copied </p>", 
        "returns": "size_t", 
        "warning": null, 
        "params": [
            {
                "type": "ResHandle", 
                "name": "h", 
                "description": "<p>The handle to the resource </p>"
            }, 
            {
                "type": "uint8_t *", 
                "name": "buffer", 
                "description": "<p>The buffer to load the resource data into </p>"
            }, 
            {
                "type": "size_t", 
                "name": "max_length", 
                "description": "<p>The maximum number of bytes to copy </p>"
            }
        ], 
        "description": "<p>Copies the bytes for the resource with a given handle from flash storage into a given buffer."
    }, 
    "menu_layer_create": {
        "kind": "fn", 
        "name": "menu_layer_create", 
        "return_desc": "<p>A pointer to the MenuLayer. NULL if the MenuLayer could not be created </p>", 
        "returns": "MenuLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": null
            }
        ], 
        "description": "<p>Creates a new MenuLayer on the heap and initalizes it with the default values.</p><p><ul><li><p>Clips: true</p></li><li><p>Hidden: false</p></li><li><p>Content size: frame.size</p></li><li><p>Content offset: GPointZero</p></li><li><p>Callbacks: None (NULL for each one)</p></li><li><p>Callback context: NULL</p></li><li><p>After the relevant callbacks are called to populate the menu, the item at MenuIndex(0, 0) will be selected initially. </li></ul>\n</p>"
    }, 
    "TUPLE_CSTRING": {
        "kind": "enum", 
        "name": "TUPLE_CSTRING", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The value is a zero-terminated, UTF-8 C-string. </p>"
    }, 
    "app_sync_deinit": {
        "kind": "fn", 
        "name": "app_sync_deinit", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "AppSync", 
                "name": "s", 
                "description": "<p>The AppSync context to deinit. </p>"
            }
        ], 
        "description": "<p>Cleans up an AppSync system. It frees the buffer allocated by an <code>app_sync_init()</code> call and deregisters itself from the AppMessage subsystem."
    }, 
    "app_message_outbox_size_maximum": {
        "kind": "fn", 
        "name": "app_message_outbox_size_maximum", 
        "return_desc": "<p>The outbox size maximum on this firmware.</p>", 
        "returns": "uint32_t", 
        "warning": null, 
        "params": [], 
        "description": "<p>Programatically determine the outbox size maximum in the current configuration.</p><p>\n</p>"
    }, 
    "bitmap_layer_set_bitmap": {
        "kind": "fn", 
        "name": "bitmap_layer_set_bitmap", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "BitmapLayer *", 
                "name": "bitmap_layer", 
                "description": "<p>The BitmapLayer for which to set the bitmap image </p>"
            }, 
            {
                "type": "const GBitmap *", 
                "name": "bitmap", 
                "description": "<p>The new GBitmap to set onto the BitmapLayer </p>"
            }
        ], 
        "description": "<p>Sets the bitmap onto the BitmapLayer. The bitmap is set by reference (no deep copy), thus the caller of this function has to make sure the bitmap is kept in memory.</p><p>The bitmap layer is automatically marked dirty after this operation. \n</p>"
    }, 
    "ACCEL_AXIS_Y": {
        "kind": "enum", 
        "name": "ACCEL_AXIS_Y", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Accelerometer's Y axis. The positive direction along the Y axis goes toward the top of the watch. </p>"
    }, 
    "ACCEL_AXIS_X": {
        "kind": "enum", 
        "name": "ACCEL_AXIS_X", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Accelerometer's X axis. The positive direction along the X axis goes toward the right of the watch. </p>"
    }, 
    "ACCEL_AXIS_Z": {
        "kind": "enum", 
        "name": "ACCEL_AXIS_Z", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Accelerometer's Z axis. The positive direction along the Z axis goes vertically out of the watchface. </p>"
    }, 
    "DATA_LOGGING_FULL": {
        "kind": "enum", 
        "name": "DATA_LOGGING_FULL", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>No more space to save data. </p>"
    }, 
    "app_message_get_context": {
        "kind": "fn", 
        "name": "app_message_get_context", 
        "return_desc": "<p>The current context on record. </p>", 
        "returns": "void *", 
        "warning": null, 
        "params": [], 
        "description": "<p>Gets the context that will be passed to all AppMessage callbacks.</p><p>"
    }, 
    "E_INVALID_OPERATION": {
        "kind": "enum", 
        "name": "E_INVALID_OPERATION", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Operation not allowed (may depend on state). </p>"
    }, 
    "graphics_draw_pixel": {
        "kind": "fn", 
        "name": "graphics_draw_pixel", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "GContext *", 
                "name": "ctx", 
                "description": "<p>The destination graphics context in which to draw </p>"
            }, 
            {
                "type": "GPoint", 
                "name": "point", 
                "description": "<p>The point at which to draw the pixel </p>"
            }
        ], 
        "description": "<p>Draws a pixel at given point in the current stroke color"
    }, 
    "APP_MSG_ALREADY_RELEASED": {
        "kind": "enum", 
        "name": "APP_MSG_ALREADY_RELEASED", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>The resource had already been released. </p>"
    }, 
    "animation_set_curve": {
        "kind": "fn", 
        "name": "animation_set_curve", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>It is up to the implementation of the animation to actually use the curve. Because a curve type is often used for animations, it is included in the animation base layer. </p>", 
        "params": [
            {
                "type": "Animation", 
                "name": "animation", 
                "description": "<p>The animation for which to set the curve. </p>"
            }, 
            {
                "type": "AnimationCurve", 
                "name": "curve", 
                "description": "<p>The type of curve. </p>"
            }
        ], 
        "description": "<p>Sets the animation curve for the animation."
    }, 
    "TextLayer": {
        "kind": "typedef", 
        "name": "TextLayer", 
        "return_desc": null, 
        "returns": "struct TextLayer", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "layer_get_data": {
        "kind": "fn", 
        "name": "layer_get_data", 
        "return_desc": "<p>A void pointer to the data region. </p>", 
        "returns": "void *", 
        "warning": null, 
        "params": [
            {
                "type": "const Layer *", 
                "name": "layer", 
                "description": "<p>The layer to get the data region from. </p>"
            }
        ], 
        "description": "<p>Gets the data from a layer that has been created with an extra data region."
    }, 
    "TRIG_MAX_ANGLE": {
        "kind": "def", 
        "name": "TRIG_MAX_ANGLE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Angle value that corresponds to 360 degrees or 2 PI radians \n</p>"
    }, 
    "ACCEL_SAMPLING_100HZ": {
        "kind": "enum", 
        "name": "ACCEL_SAMPLING_100HZ", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>100 HZ sampling rate </p>"
    }, 
    "window_set_fullscreen": {
        "kind": "fn", 
        "name": "window_set_fullscreen", 
        "return_desc": null, 
        "returns": "void", 
        "warning": "<p>This needs to be called before pushing a window to the window stack. </p>", 
        "params": [
            {
                "type": "Window *", 
                "name": "window", 
                "description": "<p>The window for which to set its full-screen property </p>"
            }, 
            {
                "type": "bool", 
                "name": "enabled", 
                "description": "<p>True to make the window full-screen or false to leave space for the system status bar. </p>"
            }
        ], 
        "description": "<p>Sets whether or not the window is fullscreen, consequently hiding the sytem status bar. \n</p>"
    }, 
    "PBL_APP_INFO_SIMPLE": {
        "kind": "def", 
        "name": "PBL_APP_INFO_SIMPLE", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": ""
    }, 
    "AnimationStartedHandler": {
        "kind": "typedef", 
        "name": "AnimationStartedHandler", 
        "return_desc": null, 
        "returns": "void(*", 
        "warning": "<p>This is called after any optional delay as set by <code>animation_set_delay()</code> has expired. </p>", 
        "params": [], 
        "description": "<p>The function pointer type of the handler that will be called when an animation is started, just before updating the first frame of the animation. \n</p>"
    }, 
    "text_layer_create": {
        "kind": "fn", 
        "name": "text_layer_create", 
        "return_desc": "<p>A pointer to the TextLayer. NULL if the TextLayer could not be created </p>", 
        "returns": "TextLayer *", 
        "warning": null, 
        "params": [
            {
                "type": "GRect", 
                "name": "frame", 
                "description": "<p>The frame with which to initialze the TextLayer </p>"
            }
        ], 
        "description": "<p>Creates a new TextLayer on the heap and initializes it with the default values.</p><p><ul><li><p>Font: Raster Gothic 14-point Boldface (system font)</p></li><li><p>Text Alignment: GTextAlignmentLeft</p></li><li><p>Text color: GColorBlack</p></li><li><p>Background color: GColorWhite</p></li><li><p>Clips: true</p></li><li><p>Hidden: false</p></li><li><p>Caching: false</p></li></ul>\n</p><p>The text layer is automatically marked dirty after this operation."
    }, 
    "GCornerTopLeft": {
        "kind": "enum", 
        "name": "GCornerTopLeft", 
        "return_desc": null, 
        "returns": "", 
        "warning": null, 
        "params": [], 
        "description": "<p>Top-Left corner. </p>"
    }, 
    "dict_merge": {
        "kind": "fn", 
        "name": "dict_merge", 
        "return_desc": "<p><code>DICT_OK</code>, <code>DICT_INVALID_ARGS</code>, <code>DICT_NOT_ENOUGH_STORAGE</code> </p>", 
        "returns": "DictionaryResult", 
        "warning": null, 
        "params": [
            {
                "type": "DictionaryIterator", 
                "name": "dest", 
                "description": "<p>The destination dictionary to update </p>"
            }, 
            {
                "type": "uint32_t *", 
                "name": "dest_max_size_in_out", 
                "description": "<p>In: the maximum size of buffer backing dest. Out: the final size of the updated dictionary. </p>"
            }, 
            {
                "type": "DictionaryIterator", 
                "name": "source", 
                "description": "<p>The source dictionary of which its Tuples will be used to update dest. </p>"
            }, 
            {
                "type": "const bool", 
                "name": "update_existing_keys_only", 
                "description": "<p>Specify True if only the existing keys in dest should be updated. </p>"
            }, 
            {
                "type": "DictionaryKeyUpdatedCallback", 
                "name": "key_callback", 
                "description": "<p>The callback that will be called for each Tuple in the merged destination dictionary. </p>"
            }, 
            {
                "type": "void *", 
                "name": "context", 
                "description": "<p>Pointer to app specific data that will get passed in when <code>update_key_callback</code> is called. </p>"
            }
        ], 
        "description": "<p>Merges entries from another \"source\" dictionary into a \"destination\" dictionary. All Tuples from the source are written into the destination dictionary, while updating the exsting Tuples with matching keys."
    }, 
    "rot_bitmap_set_src_ic": {
        "kind": "fn", 
        "name": "rot_bitmap_set_src_ic", 
        "return_desc": null, 
        "returns": "void", 
        "warning": null, 
        "params": [
            {
                "type": "RotBitmapLayer *", 
                "name": "image", 
                "description": null
            }, 
            {
                "type": "GPoint", 
                "name": "ic", 
                "description": null
            }
        ], 
        "description": ""
    }
}